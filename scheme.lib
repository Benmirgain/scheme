//
version="version scheme.lib 1.0.0.0 Apr_2021 ";
category="Algebraic geometry"; 
info="
LIBRARY: scheme.lib  Schemes

AUTHORS:  Benjamin Mirgain
          Janko Boehm, e-mail:boehm@mathematik.uni-kl.de

OVERVIEW:
The library implements various new classes centered around schemes.

The chart type represents an affine chart of the form Spec R/I, with I being an ideal and 
R being the ring it is defined in. There is a constructor for charts which can be called by 
assigning an ideal using =.

The ratFunc type represents a rational function and is made to be ring independent. This type
is used to define morphisms between charts and schemes. You can use +, -, *, /, == for addition, 
substraction, multiplication, division and comparison. The constructor can be called by 
assigning one or two polynomials to a rational function via =.

The chartmap type represents a morphism from an open subset of a chart to another chart, it 
contains two charts preim and im, representing the image and preimage of the morphism, as well as 
an ideal dom, being ideal defining the locus that is the complement of the open subset of preim 
which is the domain of the chartmap, furthermore it contains a list ratFuncs containing the 
rational functions which are the images of the variables of the ring in im under the ring morphism
induced by the charmap. You can use * in order to compute the composition of two chartmaps, as 
long as they are compatible. The contructor of chartmaps can be called by using =.

The scheme type is made up of two lists one containing the charts covering the scheme and the other 
containing the gluing morphisms between the charts.

The divisor type represents a divisor of scheme. It contains a scheme space, representing the ambient
space the divisor is in, as well as two lists schemes and mults, the forst containing the schemes
which make up the divisor and the second containg the corresponding multiplicities. You can add and 
substract divisors via + and -.

The morphism type represents a morphism between two schemes, it contains two schemes preim and im,
representing the image and preimage of the morphism, as well as a list chartmaps containing the 
chartmaps between the charts of preim and the charts of im induced by the morphism. You can use * 
to compute the composition of two morphisms.

Lastly the blowUpMap type is a type which represents the morphism of a blow up. In contrast two the
morphism type it also contains all the relevant information of a blow up. It contains four schemes
base, representing the base scheme, blow, representing the blow up, center, representing the center
of the blow up, and exDiv, representing the exceptional divisor. Furthermore the list maps contains
the maps contains the chartmaps defining the morphism.



KEYWORDS:
schemes, divisors

PROCEDURES:
blowUp(X,Y); computes the blow up of scheme X along the center Y
BlowUpMapToMorphism(pi); converts a blowUpMap pi to a morphism
ChartmapCompChartmap(phi,psi); Computes the composition of the chartmap phi with the chartmap psi
ChartmapCompIdeal(phi,I); Computes the inverse image under phi of the closed subscheme defined by the ideal I
ChartmapToMorphism(phi); converts a chartmap phi to a morphism
ChartToScheme(U); converts chart U to a scheme
CompleteIntersectionCover(X,W); Computes a scheme isomorphic to X, where each chart is a complete intersection
dimension(X); computes the dimension of the scheme X
FibreProduct(X,Y); computes the fibre product of the scheme X with the scheme Y
HybrSmoothTest(X); smoothness test for scheme X, only works for equidimensional X
Image(phi,X); computes the image of a subscheme X under a morphism phi
intersection(X,Y); computes the scheme theoretic intersection of the schemes X and Y
IntersectionNumber(D1,...); computes the intersection of the divisors D1,...
InvImage(Y,phi); computes the inverse image of the scheme Y under the morphism phi
IrredDec(X); computes the scheme theoretical irreducible decomposition of the scheme X
isReduced(X); checks whether given scheme is reduced
isSmooth(X); checks whether given scheme is smooth
itCompleteIntersctionCover(X,W); iterative version of CompleteIntersectionCover
makeAffineScheme(I); constructs the affine scheme Spec R/I, where R=basering
makeChart(I); constructor for chart type
makeChartmap(U,V,Dom,L); constructor for chartmap type
makeDivisor((Y1,m1),(Y2,m2),...,X); constructor for divisor type
makeMorphism(X,Y,L); constructor for morphism type
makeProjScheme(I); constructs the projective scheme Proj R/I, where R=basering and I homogeneous
makeratFunc(f[,g]); constructor for ratFunc type
maps(i,j,X); computes the gluing map from the i-th chart to the j-th of a iterativeScheme X
MorphismCompMorphism(phi,psi); Computes the composition of the morphism phi with the morphism psi
PolyCompratFunc(P,r_1,...,r_n); replaces the variables of the Poly P by the ratFuncs r_1,...,r_n
ratFuncCompratFunc(F,r_1,...,r_n); replaces the variables of the ratFunc F by the ratFuncs r_1,...,r_n
ReducedScheme(X); computes the reduced scheme of a given scheme X
strictTransform(X,pi); strict transformation of X along the blowUpMap pi
union(X,Y); computes the scheme theoretic union of the schemes X and Y

";


LIB "idealclass.lib";
LIB "sing.lib";
LIB "elim.lib";
LIB "polyclass.lib";
LIB "primdec.lib";
LIB "matrix.lib";
LIB "grobcov.lib";
LIB "elim.lib";
LIB "presolve.lib";
LIB "gfan.lib";



static proc mod_init()
{
  newstruct("chart","ring in, ideal value");
  newstruct("chartmap","chart preim, chart im, ideal dom, list ratFuncs");
  newstruct("scheme","list cover, list maps");
  newstruct("affVariety","ring in, ideal value");
  newstruct("projVariety","ring in, ideal value");
  newstruct("product","ring in, ideal value, list gradings");
  newstruct("morphism","scheme preim, scheme im, list chartmaps");
  newstruct("affRatMap","affVariety preim, affVariety im, list ratFuncs");
  newstruct("projRatMap","projVariety preim, projVariety im, list ratFuncs");
  newstruct("divisor","scheme space, list schemes, list mults");
  newstruct("ratFunc","ring in, poly num, poly den");
  newstruct("blowUpMap","scheme blow, scheme base, scheme exDiv, scheme center, list maps");
  newstruct("iterativeScheme","list cover, list maps");
  newstruct("iterativeChart","def parent, chart entry, chartmap parentmap, chartmap parentInverseMap, intvec label");
  newstruct("coherentSheaf","list cover, def space");
  
  system("install","chart","=",makeChart,1);
  system("install","chartmap","=",makeChartmap,1);
  system("install","chart","print",printChart,1);
  system("install","chartmap","print",printChartmap,1);
  system("install","chart","==",equalChart,2);
  system("install","chart","!=",notequalChart,2);
  system("install","chartmap","==",equalChartmap,2);
  system("install","chartmap","!=",notequalChartmap,2);
  system("install","affVariety","=",makeaffVar,1);
  system("install","affVariety","print",printAffVariety,1);
  system("install","affVariety","==",equalAffVariety,2);
  system("install","affVariety","!=",notequalAffVariety,2);
  system("install","projVariety","=",makeprojVar,1);
  system("install","projVariety","print",printProjVariety,1);
  system("install","projVariety","==",equalProjVariety,2);
  system("install","projVariety","!=",notequalProjVariety,2);
  system("install","affRatMap","print",printAffRatMap,1);
  system("install","projRatMap","print",printProjRatMap,1);
  system("install","affRatMap","*",affRatMapCompaffRatMap,2);
  system("install","projRatMap","*",projRatMapCompprojRatMap,2);
  system("install","affRatMap","==",isSameMap,2);
  system("install","projRatMap","==",isSameMap,2);
  system("install","affRatMap","!=",isnotSameMap,2);
  system("install","projRatMap","!=",isnotSameMap,2);
  system("install","scheme","==",equalScheme,2);
  system("install","scheme","!=",notequalScheme,2);
  system("install","scheme","print",printScheme,1);
  system("install","ratFunc","=",makeratFunc,1);
  system("install","ratFunc","print",printratFunc,1);
  system("install","ratFunc","string",stringratFunc,4);
  system("install","ratFunc","+",addratFunc,2);
  system("install","ratFunc","-",subratFunc,2);
  system("install","ratFunc","*",multratFunc,2); 
  system("install","ratFunc","/",divideratFunc,2);
  system("install","ratFunc","==",equalratFunc,2);
  system("install","ratFunc","!=",notequalratFunc,2);
  system("install","ratFunc","^",expratFunc,2);
  system("install","chartmap","[",ChartmapCompIdeal,2);
  system("install","chartmap","*",ChartmapCompChartmap,2);
  system("install","divisor","=",makeDivisor,1);
  system("install","divisor","+",AddDivisor,2);
  system("install","divisor","-",SubDivisor,2);
  system("install","divisor","*",intTimesDivisor,2);
  system("install","morphism","=",makeMorphism,1);
  system("install","morphism","*",MorphismCompMorphism,2);
  system("install","iterativeChart","print",printItChart,1);
  system("install","iterativeScheme","print",printItScheme,1);
}


///////////////////////////////////////////////////
//    Intersection Number
///////////////////////////////////////////////////

//Used for calculations in IntersectionNumber
static proc partSum(scheme X, int i, int lower, int upper, ideal S)
{
    int result=0;
	int l=lower;
	ideal I;
	while(l<=upper)
	{
	      I=X.maps[i][l].dom;
		  def L=sat(S,I);
		  result=result+vdim(L[1]);
		  result=result-partSum(X,i,l+1,upper,L[1]);
		  l=l+1;
		  kill L;
	}
	return(result);
}


proc IntersectionNumber(list #)
"USAGE: IntersectionNumber(D1,D2,...,Dn); D1,D2,... divisors
ASSUME: The inputs all lie in general position in the same ambient space and 
        the number of inputs is equal to the dimension of the ambient space
RETURN: The intersection number of the inputs
EXAMPLE: example IntersectionNumber; shows an example"
{
    def S=basering;
    int i,j,k,l;
	if(typeof(#[1])!="divisor")
	{   ERROR("Wrong inputs!");}
	scheme X=#[1].space;
	if(size(#)!=dimension(X))
	{   ERROR("Wrong number of inputs!");}
	for(k=1; k<=size(#); k=k+1)
	{
	   if(typeof(#[k])!="divisor")
	   {   ERROR("Wrong inputs!");}
	   if(#[k].space!=X)
	   {   ERROR("Incompatible inputs!");}
	}
	scheme Z;
    int result=0;
	intvec iv;
	int n=1;
	for(i=1; i<=size(#); i=i+1)
	{
	   n=n*size(#[i].schemes);
	}
	for(i=1;i<=n;i=i+1)
	{
	    j=i-1;
		for(k=1; k<=size(#); k=k+1)
		{
		   iv[k]=(j % size(#[k].schemes))+1;
		   j=j div size(#[k].schemes);
		}
		j=iv[1];
		Z=#[1].schemes[j];
		for(k=2; k<=size(#); k=k+1)
        {
	        j=iv[k];
			Z=intersection(Z,#[k].schemes[j]);
		}
		if(dimension(Z)!=0)
		{   ERROR("Divisors not in general position!");}
		for(l=1;l<=size(X.cover);l=l+1)
	    {
		    def R=X.cover[l].in;
			setring R;
			int d=vdim(std(Z.cover[l].value+X.cover[l].value));
			k=l+1;
			while((d>0) and (k<=size(X.cover)))
			{
			    ideal K=X.maps[l][k].dom;
				def L=sat(Z.cover[l].value+X.cover[l].value,K);
				kill K;
				d=d-vdim(L[1]);
				d=d+partSum(X,l,l+1,k-1,L[1]);
			    k=k+1;
				kill L;
			}
			for(k=1; k<=size(#); k=k+1)
			{
			    j=iv[k];
				d=d*#[k].mults[j];
			}
			result=result+d;
			kill d,R;
	    }
		setring S;
	}
	
	setring S;
	return(result);
}
example
{
"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(0);
scheme Y=makeProjScheme(ideal(x-z),X);
divisor A=list(Y,2),X;
Y=makeProjScheme(ideal(x2-zy),X);
scheme Z=makeProjScheme(ideal(x2z-z2y+y3),X);
divisor B=list(Y,1),list(Z,1),X;
Y=makeProjScheme(ideal(y),X);
divisor C=list(Y,1),X;
IntersectionNumber(3*C-A,B);
}



//////////////////////////////////////////////////////////////////////////
//      Chart stuff
//////////////////////////////////////////////////////////////////////////

proc makeChart(ideal I)
"USAGE: makeChart(I); ideal I
RETURN: chart representing Spec R/I, where R=basering
EXAMPLE: example makeChart; shows an example"
{
   chart C;
   C.in=basering;
   C.value=I;
   return(C);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
chart U=ideal(x2-yz);
U;
}

// For comparing charts
static proc equalChart(chart U, chart V)
{
   if(U.in!=V.in)
   {
      return(0);
   }else{
      def R=basering;
	  def S=U.in;
	  setring S;
	  
	  if((std(quotient(U.value,V.value))!=1)&&(std(quotient(V.value,U.value))!=1))
	  {
	     setring R;
		 return(0);
	  }
	  
	  setring R;
	  return(1);
   }
}

// Also for comparing charts
static proc notequalChart(chart U, chart V)
{
   return(!equalChart(U,V));
}


proc makeChartmap(chart Preim, chart Im, list #)
"USAGE: makeChartmap(Preim,Im,Dom,L); Preim,Im=charts, Dom=ideal/Ideal, L=list
        makeChartmap(Preim,Im,L); Preim,Im=charts, L=list
ASSUME: Dom has to belong to the ring Preim.in
        The list L is supposed to contain the entries of the list ratFuncs from the output
        If n=size(Dom) and m=nvars(Im.in), then the list L should either be a list of n 
		lists with m ratFunc types each, or it should be a list of n*m ratFunc types in which 
		case the first m entries fill up the first list of ratFuncs and so on.
RETURN: chartmap with the given input as data, if Dom is not given as an input, then it 
        is the ideal dom from the output will represent the largest possible domain
EXAMPLE: example makeChartmap; creates an example"
{  
   chartmap result;
   result.preim=Preim;
   result.im=Im;
   int i,j;
   intvec iv;
   
   def R=basering;
   def S=Preim.in;
   def SS=Im.in;
   
   setring S;
   ideal Dom;
   poly f;
   if((typeof(#[1])=="ideal")||(typeof(#[1])=="Ideal"))
   {
      if(typeof(#[1])=="Ideal")
	  {
		 Dom=#[1].value;
	  }
	  else
	  {
	     Dom=#[1];
	  }
	  result.dom=Dom;
	  #=delete(#,1);
	  if(typeof(#[1])=="list")
	  {
	     if(typeof(#[1][1])=="ratFunc")
		 {
		    if(size(#)>1)
			{
		    if(size(#)!=size(Dom))
	        {   ERROR("Incorrect number of inputs!");}
	        result.ratFuncs=#;
			}else{
			#=#[1];
			}
		 }else{
	     #=#[1];
		 if(typeof(#[1])=="list")
		 {
	     if(size(#)!=size(Dom))
	     {   ERROR("Incorrect number of inputs!");}
	     result.ratFuncs=#;
		 }}		 
	  } 
      if(typeof(#[1])=="ratFunc")
      {
         if(size(#)!=size(Dom)*nvars(SS))
	     {   ERROR("Incorrect number of inputs!");}
	     for(i=1; i<=size(Dom); i=i+1)
	     {
		    result.ratFuncs[i]=list();
			for(j=1; j<=nvars(SS); j=j+1)
			{
			   result.ratFuncs[i][j]=#[(i-1)*nvars(SS)+j];
			}
	     }
      }
   }
   else
   {
      if(typeof(#[1])=="list")
	  {
	     f=1;
		 for(j=1; j<=size(#); j=j+1)
		 {
		    f=1;
		    for(i=1; i<=size(#[j]); i=i+1)
			{
			    f=lcm(f,#[j][i].den);
			}
			Dom=Dom+f;
		 }
		 result.dom=Dom;
		 result.ratFuncs=#;
	  }	  
      if(typeof(#[1])=="ratFunc")
      {
         if((size(#)%nvars(SS))!=0)
	     {   ERROR("Incorrect number of inputs!");}
		 int s=size(#) div nvars(SS);
	     for(i=1; i<=s; i=i+1)
	     {
		    result.ratFuncs[i]=list();
			f=1;
			for(j=1; j<=nvars(SS); j=j+1)
			{
			   f=lcm(f,#[(i-1)*nvars(SS)+j].den);
			   result.ratFuncs[i][j]=#[(i-1)*nvars(SS)+j];
			}
			Dom=Dom+f;
	     }
		 result.dom=Dom;
      }
   }
   
   kill Dom,f;
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(a,b,c,d),dp;
chart U=ad-bc;
Ideal I=ideal(c,d);
ratFunc F=a,c;
ratFunc G=b,d;
list L=list(list(F),list(G));
ring S=0,(x),dp;
chart V=0;

chartmap phi=U,V,I,L;
phi;

chartmap psi=U,V,I,F,G;
psi==phi;

psi=U,V,L;
psi==phi;

psi=U,V,F,G;
psi==phi;
}

// Print routine for chart
static proc printChart(chart C)
{
   def R=basering;
   def S=C.in;
   setring S;
   "ring = "+string(S);
   "quotient = "+string(C.value);
   setring R;
}

// Print routine for chartmap
static proc printChartmap(chartmap phi)
{
   def B=basering;
   def R=phi.preim.in;
   def S=phi.im.in;
   int i,k;

   setring R;
   "Preimage ring: ("+string(R)+")/("+string(phi.preim.value)+")"; 
   "Domain: D("+string(phi.dom)+")";   
   setring S;
   "Image ring: ("+string(S)+")/("+string(phi.im.value)+")";
   string st;
   int n=size(phi.ratFuncs);
   int m=nvars(S);
   for(k=1; k<=n; k=k+1)
   {
   setring R;
   "Map restricted to D("+string(phi.dom[k])+"):";
   st="     ("+varstr(R)+") -----> ( ";   
   for(i=1; i<m; i=i+1)
   {
      st=st+string(phi.ratFuncs[k][i])+" , ";
   }
   st=st+string(phi.ratFuncs[k][m])+" )";
   st;
   }
   setring B;
}

// Used for comparing chartmaps
static proc equalChartmap(chartmap phi, chartmap psi)
{
   if((phi.preim!=psi.preim)||(phi.im!=psi.im))
   {
      return(0);
   }
   
   def R=basering;
   def S=phi.preim.in;
   setring S;
   
   if(size(phi.dom)!=size(psi.dom))
   {
      setring R;
	  return(0);
   }
   
   int i,j;
   for(i=1; i<=size(phi.dom); i=i+1)
   {
      if(phi.dom[i]!=psi.dom[i])
	  {
	     setring R;
		 return(0);
	  }
   }
   
   
   for(i=1; i<=size(phi.dom); i=i+1)
   {
      for(j=1; j<=size(phi.ratFuncs[i]); j=j+1)
      {
	     poly f=phi.ratFuncs[i][j].num*psi.ratFuncs[i][j].den-psi.ratFuncs[i][j].num*phi.ratFuncs[i][j].den;
		 if(std(reduce(f,sat(phi.preim.value,ideal(phi.dom[i]))[1]))!=0)
		 {
		    setring R;
		    return(0);
		 }
		 kill f;
      }
   }
   
   setring R;
   return(1);
}

// Used for comparing chartmaps
static proc notequalChartmap(chartmap phi, chartmap psi)
{
   return(!equalChartmap(phi,psi));
}

static proc equalAffVariety(affVariety X, affVariety Y)
{
	if(X.in!=Y.in)
	{
		return(0);
	}
	def B=basering;
	def R=X.in;
	setring R;
	if((reduce(X.value,std(Y.value))==0)&&(reduce(Y.value,std(X.value))==0))
	{
		setring B;
		return(1);
	}
	else
	{
		setring B;
		return(0);
	}
}

static proc notequalAffVariety(affVariety X, affVariety Y)
{
	return(!equalAffVariety(X,Y));
}

static proc equalProjVariety(projVariety X, projVariety Y)
{
	if(X.in!=Y.in)
	{
		return(0);
	}
	def B=basering;
	def R=X.in;
	setring R;
	if((reduce(X.value,std(Y.value))==0)&&(reduce(Y.value,std(X.value))==0))
	{
		setring B;
		return(1);
	}
	else
	{
		setring B;
		return(0);
	}
}

static proc notequalProjVariety(projVariety X, projVariety Y)
{
	return(!equalProjVariety(X,Y));
}

// Used for comparing schemes
static proc equalScheme(scheme X, scheme Y)
{
   int i,j;
   
   if(size(X.cover)!=size(Y.cover))
   {
      return(0);
   }
   
   for(i=1; i<=size(X.cover); i=i+1)
   {
      if(X.cover[i]!=Y.cover[i])
	  {
	     return(0);
	  }
   }
   
   for(i=1; i<=size(X.cover); i=i+1)
   {
      for(j=1; j<=size(X.cover); j=j+1)
	  {
	     if(X.maps[i][j]!=Y.maps[i][j])
		 {
		    return(0);
		 }
	  }
   }
   
   return(1);
}

// Used for comparing schemes
static proc notequalScheme(scheme X, scheme Y)
{
   return(!equalScheme(X,Y));
}

// Print routine for schemes
static proc printScheme(scheme X)
{
   def R=basering;
   int i,j,k,m,l;
   for(i=1; i<=size(X.cover); i=i+1)
   {
      "Chart U"+string(i)+":";
      X.cover[i];
   }
   "";
   chartmap phi;
   for(i=1; i<=size(X.cover); i=i+1)
   {
      for(j=1; j<=size(X.cover); j=j+1)
	  {
	     "Map U"+string(i)+" -> U"+string(j)+":";
		 
	     phi=X.maps[i][j];
         def T=phi.preim.in;
         def S=phi.im.in;
         
		 setring T;
		 "Domain: D("+string(phi.dom)+")";  
		 
         setring S;
         string st;
         m=nvars(S);
         for(k=1; k<=size(phi.ratFuncs); k=k+1)
         {
         setring T;
         "Map restricted to D("+string(phi.dom[k])+"):";
         st="     ("+varstr(T)+") -----> ( ";   
         for(l=1; l<m; l=l+1)
         {
            st=st+string(phi.ratFuncs[k][l])+" , ";
         }
         st=st+string(phi.ratFuncs[k][m])+" )";
         st;
		 "";
         }
		 kill st;
		 kill T,S;
	  }
   }
   setring R;
}


proc ChartToScheme(chart U)
"USAGE: ChartToScheme(U); chart U
RETURN: scheme type corresponding to the affine scheme that corresponds to U
EXAMPLE: example ChartToScheme; creates an example"
{
    def R=basering;
	scheme result;
	
	result.cover[1]=U;
	def S=U.in;
	setring S;
	
	list L;
	ratFunc r;
	for(int i=1;i<=nvars(S);i=i+1)
	{
	   r=var(i);
	   L[i]=r;
	}
	chartmap Phi=U,U,L;
	result.maps=list(list(Phi));
	
	setring R; 
	return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
chart U=x2-y3;
scheme X=ChartToScheme(U);
X;
scheme Y=makeAffineScheme(x2-y3);
X==Y;
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   Variety Stuff
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


proc makeaffVar(ideal I)
{
	affVariety result;
	result.in=basering;
	result.value=I;
	return(result);
}


proc makeprojVar(ideal I)
{
	if(!homog(I))
	{   ERROR(Input has to be homogeneous)}
	projVariety result;
	result.in=basering;
	result.value=I;
	return(result);
}


proc makeProduct(list #)
{
	def B=basering;
	product result;
	int i,j,k;

	if(typeof(#[1])=="ideal")
	{
	if(size(#)==1)
	{
		result.in=B;
		result.value=#[1];
		intvec iv;
		for(i=1; i<=nvars(B); i=i+1)
		{
			iv[i]=deg(var(i));
		}
		result.gradings=list(list(iv,"projective"));

		kill iv;
		return(result);
	}

	if(typeof(#[2])=="int")
	{
		result.in=B;
		result.value=#[1];

		int varcount=0;
		for(i=2; i<=size(#); i=i+1)
		{
			intvec iv=0:nvars(B);
			if(varcount+#[i]>nvars(B))
			{   ERROR("Input incorrect")}
			for(j=1; j<=#[i]; j=j+1)
			{
				varcount=varcount+1;
				iv[varcount]=deg(var(varcount));
			}

			result.gradings[i-1]=list(iv,"projective");
			kill iv;
		}

		if(varcount!=nvars(B))
		{   ERROR("Input incorrect")}
		kill varcount;

		return(result);
	}

	if(typeof(#[2])=="poly")
	{
		result.in=B;
		result.value=#[1];

		poly pvars1=1;
		poly pvars2=1;
		for(i=1; i<=nvars(B); i=i+1)
		{
			pvars2=pvars2*var(i);
		}

		for(i=2; i<=size(#); i=i+1)
		{
			intvec iv;
			for(j=1; j<=nvars(B); j=j+1)
			{
				if(#[i]/var(j)!=0)
				{
					iv[j]=deg(var(j));
				}else{
					iv[j]=0;
				}
			}
			result.gradings[i-1]=list(iv,"projective");
			kill iv;
			pvars1=pvars1*#[i];
		}

		if(pvars1!=pvars2)
		{   ERROR("Input incorrect")}

		kill pvars1,pvars2;

		return(result);
	}
	}

	list L;
	if(typeof(#[1])=="list")
	{
		L=#[1];
	}else{
		L=#;
	}

	if((typeof(L[1])=="affVariety")||(typeof(L[1])=="projVariety")||(typeof(L[1])=="product"))
	{
	def R=L[1].in;
	setring R;
	ideal I=L[1].value;
	list grad;
	if(typeof(L[1])=="affVariety")
	{
		intvec iv=1:nvars(R);
		grad[1]=list(iv,"affine");
		kill iv;
	}
	if(typeof(L[1])=="projVariety")
	{
		intvec iv;
		for(j=1; j<=nvars(R); j=j+1)
		{
			iv[j]=deg(var(j));
		}
		grad[1]=list(iv,"projective");
		kill iv;
	}
	if(typeof(L[1])=="product")
	{
		grad=L[1].gradings;
	}
	for(i=2; i<=size(L); i=i+1)
	{
		def S=L[i].in;
		setring S;
		ideal J=L[i].value;
		intvec iv=0:nvars(R);
		intvec jv=0:nvars(S);
		intvec kv=nvars(R)+1..nvars(R)+nvars(S);
		for(j=1; j<=size(grad); j=j+1)
		{
			grad[j][1]=grad[j][1],jv;
		}
		kill jv;

		def T=ringtensor(R,S);
		setring T;
		ideal I=fetch(R,I);
		ideal J=fetch(S,J,kv);
		kill kv;
		I=I+J;
		setring R;
		kill I;
		R=T;
		setring T;

		if(typeof(L[i])=="affVariety")
		{
			iv=iv,1:nvars(S);
			grad=grad+list(list(iv,"affine"));
		}
		if(typeof(L[i])=="projVariety")
		{
			setring S;
			intvec jv;
			for(k=1; k<=nvars(S); k=k+1)
			{
				jv[k]=deg(var(k));
			}
			iv=iv,jv;
			kill jv;
			grad=grad+list(list(iv,"projective"));
			setring T;
		}
		if(typeof(L[i])=="product")
		{
			int n=size(grad);
			grad=grad+L[i].gradings;
			for(k=n+1; k<=size(grad); k=k+1)
			{
				grad[k][1]=iv,grad[k][1];
			}
			kill n;
		}

		kill iv;
		setring S;
		kill J;
		kill S,T;
		setring R;
	}

	setring R;
	result.in=R;
	result.value=I;
	result.gradings=grad;

	return(result);
	}
}


proc printAffVariety(affVariety X)
{
	def B=basering;
	def R=X.in;
	setring R;
    "ring = "+string(R);
    "quotient = "+string(X.value);
    setring B;
}



proc printProjVariety(projVariety X)
{
	def B=basering;
	def R=X.in;
	setring R;
    "ring = "+string(R);
    "quotient = "+string(X.value);
    setring B;
}



proc printAffRatMap(affRatMap phi)
{
	def B=basering;
	def R=phi.preim.in;
	def S=phi.im.in;
    int i,k;

    setring R;
    "Preimage ring: ("+string(R)+")/("+string(phi.preim.value)+")"; 
    "Domain: D("+string(Domain(phi))+")";   
    setring S;
    "Image ring: ("+string(S)+")/("+string(phi.im.value)+")";
    string st;
	int n=nvars(R);
    int m=nvars(S);
    setring R;
    "Map:";
    st="     ( ";
	for(i=1; i<n; i=i+1)
    {
       st=st+string(var(i))+" , ";
    }
	st=st+string(var(n))+" ) -----> ( ";   
    for(i=1; i<m; i=i+1)
    {
       st=st+string(phi.ratFuncs[i])+" , ";
    }
    st=st+string(phi.ratFuncs[m])+" )";
    st;
    setring B;
}



proc printProjRatMap(projRatMap phi)
{
	def B=basering;
	def R=phi.preim.in;
	def S=phi.im.in;
    int i,k;

    setring R;
    "Preimage ring: ("+string(R)+")/("+string(phi.preim.value)+")"; 
    "Domain: D("+string(Domain(phi))+")";   
    setring S;
    "Image ring: ("+string(S)+")/("+string(phi.im.value)+")";
    string st;
	int n=nvars(R);
    int m=nvars(S);
    setring R;
    "Map:";
    st="     ( ";
	for(i=1; i<n; i=i+1)
    {
       st=st+string(var(i))+" : ";
    }
	st=st+string(var(n))+" ) -----> ( ";   
    for(i=1; i<m; i=i+1)
    {
       st=st+string(phi.ratFuncs[i])+" : ";
    }
    st=st+string(phi.ratFuncs[m])+" )";
    st;
    setring B;
}










///////////////////////////////////////////////////////////////////////////////////////////
//  Basic constructions of schemes
///////////////////////////////////////////////////////////////////////////////////////////


proc makeAffineScheme(ideal I, list #)
"USAGE: makeAffineScheme(I[,X]); I ideal, X scheme
RETURN: affine Space V(I), if scheme X is given, then V(I) is created as a subscheme of X
EXAMPLE: example makeAffineScheme; shows an example"
{
    scheme result;
	
	if(size(#)==0)
	{
	chart U=I;
	result.cover=list(U);
	
	list L;
	ratFunc r;
	for(int i=1;i<=nvars(basering);i=i+1)
	{
	   r=var(i);
	   L[i]=r;
	}
	chartmap Phi=U,U,L;
	result.maps=list(list(Phi));
	}
	
	if((size(#)==1)&&(typeof(#[1])=="scheme"))
	{
	scheme X=#[1];
	def R=basering;
	def S=X.cover[1].in;
	if((nvars(R)!=nvars(S))||(size(X.cover)!=1))
	{   ERROR("Inputs not compatible");}
	
	setring S;
	ideal J=0;
	for(int i=1;i<=nvars(S);i=i+1)
	{
	   J=J,var(i);
	}
	J=delete(J,1);
	map phi=R,J;
	
	chart U=phi(I);
	if(std(reduce(X.cover[1].value,std(U.value)))!=0)
	{   ERROR("Inputs not compatible");}
	result.cover=result.cover+list(U);
	result.maps=X.maps;
	
	result.maps[1][1].preim=U;
	result.maps[1][1].im=U;
	
	setring R;
	}
	
	return(result);
}
example
{
   "EXAMPLE:"; echo=2;
   ring R=0,(x,y),dp;
   scheme X=makeAffineScheme(ideal(0));
   X.cover;
   X.maps;
   scheme Y=makeAffineScheme(ideal(x2-y3-y2),X);
   Y.cover;
   Y.maps;
}




proc makeProjScheme(ideal I, list #)
"USAGE: makeProjScheme(I[,X]); I ideal, X scheme
RETURN: projective Space V(I), if scheme X is given, then V(I) is created as a subscheme of X
EXAMPLE: example makeProjScheme; shows an example"
{
    scheme result;
	if(!homog(I))
	{   ERROR("Ideal has to be homogeneous");}
	def R=basering;
	
	if(size(#)==0)
	{
	ring S;
	
	int n=nvars(R);
	int i,j;
	chart U;
	for(i=1;i<=n;i=i+1)
	{
	   list rl=ringlist(R);
	   rl[2]=delete(rl[2],i);
	   rl[3]=list(list("dp",1:(n-1)),list("C",0));
	   S=ring(rl);
	   
	   setring S;
	   ideal J=0;
	   for(j=1;j<=n;j=j+1)
	   {
	      if(j<i)
		  {   J=J,var(j);}
		  if(j==i)
		  {   J=J,1;}
		  if(j>i)
		  {   J=J,var(j-1);}
	   }
	   J=delete(J,1);
	   map phi=R,J; 
       kill J;	   
	   U=phi(I);
	   kill phi;
	   
	   result.cover[i]=U;
	}
	setring R;
	
	chartmap phi;
	chart Preim;
	chart Im;
	int k;
	list L;
	for(i=1;i<=n;i=i+1)
	{
	   result.maps[i]=list();
	   for(j=1;j<=n;j=j+1)
	   {
	      Preim=result.cover[i];
		  Im=result.cover[j];
		  
		  S=Preim.in;
		  setring S;
		  L=list();
		  for(k=1;k<=n;k=k+1)
		  {
		     if(k!=j)
			 {
		     if(i<j)
			 {
			    if(k<i)
				{   ratFunc rat=var(k),var(j-1);}
				if(k==i)
				{   ratFunc rat=1,var(j-1);}
				if((k>i))
				{   ratFunc rat=var(k-1),var(j-1);}
			 }
		     if(i==j)
			 {
			    if(k<j)
				{   ratFunc rat=var(k);}
				if(k>j)
				{   ratFunc rat=var(k-1);}
			 }
			 if(i>j)
			 {
			    if((k<i))
				{   ratFunc rat=var(k),var(j);}
				if(k==i)
				{   ratFunc rat=1,var(j);}
				if((k>i))
				{   ratFunc rat=var(k-1),var(j);}
			 }
			 L=L+list(rat);
			 kill rat;
			 }
		  }
		  phi=Preim,Im,L;
		  
		  result.maps[i][j]=phi;
	   }
	}
	}
	
	if((size(#)==1)&&(typeof(#[1])=="scheme"))
	{
	scheme X=#[1];
	if(nvars(R)!=size(X.cover))
	{   ERROR("Inputs are incompatible");}
	
	ring S;
	int n=nvars(R);
	int i,j;
	for(i=1;i<=n;i=i+1)
	{
	   S=X.cover[i].in;
	   if(nvars(S)!=n-1)
	   {   ERROR("Inputs are incompatible");}
	   
	   setring S;
	   ideal J=0;
	   for(j=1;j<=n;j=j+1)
	   {
	      if(j<i)
		  {   J=J,var(j);}
		  if(j==i)
		  {   J=J,1;}
		  if(j>i)
		  {   J=J,var(j-1);}
	   }
	   J=delete(J,1);
	   map phi=R,J;
	   kill J;
	   
	   chart U=phi(I);
	   if(reduce(X.cover[i].value,std(U.value))!=0)
	   {   ERROR("Inputs are incompatible");}
	   result.cover[i]=U;
	   kill phi,U;
	}
	
	result.maps=X.maps;
	for(i=1;i<=n;i=i+1)
	{
	   for(j=1;j<=n;j=j+1)
	   {
	      result.maps[i][j].preim=result.cover[i];
		  result.maps[i][j].im=result.cover[j];
	   }
	}
	}
	
	setring R;
	return(result);
}
example
{
   "EXAMPLE:"; echo=2;
   ring R=0,(x,y,z),dp;
   scheme X=makeProjScheme(ideal(0));
   X;
   scheme Y=makeProjScheme(ideal(x2z-y3-y2z),X);
   Y;
}



proc FibreProduct(scheme X, scheme Y)
"USAGE: FibreProduct(X,Y); X,Y scheme
RETURN: The Fibre Product of X and Y
EXAMPLE: example FibreProduct; shows an example"
{
   scheme result;
   def R=basering;
   int i,j,n,m,k,l;
   intvec iv,jv;
   
   for(i=1; i<=size(X.cover); i=i+1)
   {
   for(j=1; j<=size(Y.cover); j=j+1)
   {
      def Sx=X.cover[i].in;
	  def Sy=Y.cover[j].in;
	  def S=ringtensor(Sx,Sy);
	  setring S;
	  
	  n=nvars(Sx);
	  m=nvars(Sy);
	  ideal Xvars,Yvars;
	  for(k=1; k<=n; k=k+1)
	  {
	     Xvars=Xvars+var(k);
	  }
	  for(k=1; k<=m; k=k+1)
	  {
	     Yvars=Yvars+var(n+k);
	  }
	  map fx=Sx,Xvars;
	  map fy=Sy,Yvars;
	  
	  setring Sx;
	  ideal Ix=X.cover[i].value;
	  setring Sy;
	  ideal Iy=Y.cover[j].value;
	  setring S;
	  chart U=fx(Ix)+fy(Iy);
	  result.cover=result.cover+list(U);
	  
	  setring Sx;
	  kill Ix;
	  setring Sy;
	  kill Iy;
	  setring S;
	  kill U,fx,fy,Xvars,Yvars;
	  kill Sx,Sy,S;
   }}
   
   list Dx,Dy,Xpartmaps,Ypartmaps,Partmaps,Maps;
   chartmap Phi;
   for(i=1; i<=size(X.cover); i=i+1)
   {
   for(j=1; j<=size(Y.cover); j=j+1)
   {
   Maps=list();
   for(k=1; k<=size(X.cover); k=k+1)
   {
   for(l=1; l<=size(Y.cover); l=l+1)
   {
      Dx=list();
	  Dy=list();
	  Xpartmaps=list();
	  Ypartmaps=list();
	  Partmaps=list();
	  
	  def Sx=X.cover[i].in;
	  def Sy=Y.cover[j].in;
	  def S=result.cover[(i-1)*size(Y.cover)+j].in;
	  setring S;
	  
	  ideal Xvars,Yvars,Dom;
	  for(n=1; n<=nvars(Sx); n=n+1)
	  {
	     Xvars=Xvars+var(n);
	  }
	  for(n=1; n<=nvars(Sy); n=n+1)
	  {
	     Yvars=Yvars+var(n+nvars(Sx));
	  }
	  map fx=Sx,Xvars;
	  map fy=Sy,Yvars;
	  
	  Poly P;
	  ratFunc F;
      for(n=1; n<=size(X.maps[i][k].ratFuncs); n=n+1)
	  {
	     Xpartmaps[n]=list();
		 setring Sx;
		 poly f,g;
		 setring S;
		 for(m=1; m<=size(X.maps[i][k].ratFuncs[n]); m=m+1)
		 {
		    setring Sx;
			f=X.maps[i][k].ratFuncs[n][m].num;
			g=X.maps[i][k].ratFuncs[n][m].den;
			setring S;
			F=fx(f),fx(g);
			Xpartmaps[n][m]=F;
		 }
		 setring Sx;
		 f=X.maps[i][k].dom[n];
		 setring S;
		 Dx[n]=fx(f);
		 
		 setring Sx;
		 kill f,g;
		 setring S;
	  }
	  
	  for(n=1; n<=size(Y.maps[j][l].ratFuncs); n=n+1)
	  {
	     Ypartmaps[n]=list();
		 setring Sy;
		 poly f,g;
		 setring S;
		 for(m=1; m<=size(Y.maps[j][l].ratFuncs[n]); m=m+1)
		 {
		    setring Sy;
			f=Y.maps[j][l].ratFuncs[n][m].num;
			g=Y.maps[j][l].ratFuncs[n][m].den;
			setring S;
			F=fy(f),fy(g);
			Ypartmaps[n][m]=F;
		 }
		 setring Sy;
		 f=Y.maps[j][l].dom[n];
		 setring S;
		 Dy[n]=fy(f);
		 
		 setring Sy;
		 kill f,g;
		 setring S;
	  }
	  
	  for(n=1; n<=size(X.maps[i][k].ratFuncs); n=n+1)
	  {
	  for(m=1; m<=size(Y.maps[j][l].ratFuncs); m=m+1)
	  {
         Dom=Dom+Dx[n]*Dy[m];
		 Partmaps=Partmaps+Xpartmaps[n]+Ypartmaps[m];
	  }}
	  
	  Phi=result.cover[(i-1)*size(Y.cover)+j],result.cover[(k-1)*size(Y.cover)+l],Dom,Partmaps;
	  Maps=Maps+list(Phi);
	  
	  setring S;
	  kill P,F,fx,fy,Xvars,Yvars,Dom;
	  kill Sx,Sy,S;
   }}
   result.maps=result.maps+list(Maps);
   }}
   
   return(result);
}
example
{"EXAMPLE:"; "echo=2";
ring R=0,(x(1..3)),dp;
scheme X=makeProjScheme(ideal(x(1)^2-x(2)*x(3)));
ring S=0,(y(1..2)),dp;
scheme Y=makeProjScheme(ideal(y(1)-y(2)));

scheme Z=FibreProduct(X,Y);
Z;
}


proc intersection(scheme X, scheme Y)
"USAGE: intersection(X,Y); X,Y scheme
RETURN: Scheme theoretic intersection of X and Y
EXAMPLE: example intersection; shows an example"
{
   if(size(X.cover)!=size(Y.cover))
   {   ERROR("Inputs not compatible");}
   
   def R=basering;
   scheme result;
   int i,j;
   for(i=1; i<=size(X.cover); i=i+1)
   {
      if(X.cover[i].in!=Y.cover[i].in)
      {   ERROR("Inputs not compatible");}
	  
	  def S=X.cover[i].in;
	  setring S;
	  chart U=X.cover[i].value+Y.cover[i].value;
	  result.cover[i]=U;
	  
	  kill U;
	  kill S;
   }
   
   result.maps=X.maps;
   
   for(i=1; i<=size(result.cover); i=i+1)
   {
      for(j=1; j<=size(result.cover); j=j+1)
      {
	     result.maps[i][j].preim=result.cover[i];
		 result.maps[i][j].im=result.cover[j];
      }
   }
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(0);
scheme Y=makeProjScheme(ideal(x2-yz),X);
scheme Z=makeProjScheme(ideal(xy2-z3),X);

scheme S=intersection(Y,Z);
S;
}



proc union(scheme X, scheme Y)
"USAGE: union(X,Y); X,Y scheme
RETURN: Scheme theoretic union of X and Y
EXAMPLE: example union; shows an example"
{
   if(size(X.cover)!=size(Y.cover))
   {   ERROR("Inputs not compatible");}
   
   def R=basering;
   scheme result;
   int i,j;
   for(i=1; i<=size(X.cover); i=i+1)
   {
      if(X.cover[i].in!=Y.cover[i].in)
      {   ERROR("Inputs not compatible");}
	  
	  def S=X.cover[i].in;
	  setring S;
	  chart U=intersect(X.cover[i].value,Y.cover[i].value);
	  result.cover[i]=U;
	  
	  kill U;
	  kill S;
   }
   
   result.maps=X.maps;
   
   for(i=1; i<=size(result.cover); i=i+1)
   {
      for(j=1; j<=size(result.cover); j=j+1)
      {
	     result.maps[i][j].preim=result.cover[i];
		 result.maps[i][j].im=result.cover[j];
      }
   }
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(0);
scheme Y=makeProjScheme(ideal(x2-yz),X);
scheme Z=makeProjScheme(ideal(xy2-z3),X);

scheme S=union(Y,Z);
S;
}


proc ReducedScheme(scheme X)
"USAGE: ReducedScheme(X); X scheme
RETURN: The associated reduced scheme
EXAMPLE: example ReducedScheme; shows an example"
{
   def R=basering;
   scheme result;
   int i,j;
   for(i=1; i<=size(X.cover); i=i+1)
   {
      def S=X.cover[i].in;
	  setring S;
	  chart U=radical(X.cover[i].value);
	  result.cover[i]=U;
	  
	  kill U;
	  kill S;
   }
   
   result.maps=X.maps;
   
   for(i=1; i<=size(result.cover); i=i+1)
   {
      for(j=1; j<=size(result.cover); j=j+1)
      {
	     result.maps[i][j].preim=result.cover[i];
		 result.maps[i][j].im=result.cover[j];
      }
   }
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(x2y3z4);
"Original Scheme:";
X;

"Reduced Scheme:";
scheme S=ReducedScheme(X);
S;
}








//////////////////////////////////////////////////////////////////////////////////////////
//  Schemes Miscelanious
//////////////////////////////////////////////////////////////////////////////////////////

proc dimension(scheme X)
"USAGE: dimension(X); X scheme
RETURN: The dimension of the scheme X
EXAMPLE: example dimension; shows an example"
{
    def R=basering;
    int d=-1;
    for(int i=1; i<=size(X.cover); i=i+1)
	{
	   def S=X.cover[i].in;
	   setring S;
	   if(d<dim(std(X.cover[i].value)))
	   {   d=dim(std(X.cover[i].value));}
	   kill S;
	}
	
	setring R;
	return(d);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeAffineScheme(x-yz);
dimension(X);

X=makeProjScheme(x);
dimension(X);

X=makeProjScheme(ideal(x,y));
dimension(X);

X=makeProjScheme(ideal(x,y,z));
dimension(X);
}



proc IrredDec(scheme X)
"USAGE: IrredDec(X); X scheme
RETURN: A list L of the irreducible components and their associated points
            L[i][1] is the i-th irreducible component
			L[i][2] is the associated point of the i-th component
EXAMPLE: example IrredDec; shows an example"
{
    def R=basering;
	list Dec;
	
	int i,j,k,t;
	for(i=1; i<=size(X.cover); i=i+1)
	{
	   def S=X.cover[i].in;
	   setring S;
	   list L=primdecGTZ(X.cover[i].value);
	   for(j=1; j<=size(L); j=j+1)
	   {
	      Ideal Q,P;
		  Q=L[j][1];
		  P=L[j][2];
	      scheme Y,Z;
		  if(std(Q.value)!=1)
		  {
		  Y.maps=X.maps;
		  Z.maps=X.maps;
		  t=1;
		  for(k=1; k<=size(Dec); k=k+1)
		  {
		     if((std(quotient(P.value,Dec[k][2].cover[i].value))==1)&&(std(quotient(Dec[k][2].cover[i].value,P.value))==1))
			 {
			    t=0;
			 }
		  }
		  if(t)
		  {
		     for(k=1; k<=size(X.cover); k=k+1)
			 {
			    Ideal QQ,PP;
				chart CQ,CP;
				def T=X.cover[k].in;
				setring T;
				QQ=ChartmapCompIdeal(X.maps[k][i],Q);
				PP=ChartmapCompIdeal(X.maps[k][i],P);
				CQ=QQ.value;
				CP=PP.value;
				Y.cover[k]=CQ;
				Z.cover[k]=CP;
				kill T;
				kill CQ,CP,QQ,PP;
			 }
			 Dec=Dec+list(list(Y,Z));
		  }
		  setring S;
		  }
		  kill Q,P;
		  kill Y,Z;
	   }
	   
	   kill L;
	   kill S;
	}
	
	if(size(Dec)==0)
	{
	   Dec=list(list(X,X));
	}
	
	setring R;
	return(Dec);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(ideal(x2,xy));
list L=IrredDec(X);

L[1][1].cover;

L[2][1].cover;

X==union(L[1][1],L[2][1]);
}


proc isReduced(scheme X)
"USAGE: isReduced(X); X scheme
RETURN: 1 if the scheme is reduced; 0 otherwise
EXAMPLE: example isReduced; shows an example"
{
   def R=basering;
   for(int i=1; i<=size(X.cover); i=i+1)
   {
      def S=X.cover[i].in;
	  setring S;
	  if(std(quotient(X.cover[i].value,radical(X.cover[i].value)))!=1)
	  {
         setring R;	  
	     return(0);
	  }
	  
	  kill S;
   }
   
   setring R;
   return(1);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(x2y3z4);
"Original Scheme is not reduced:";
isReduced(X);

"Reduced Scheme is reduced:";
scheme S=ReducedScheme(X);
isReduced(S);
}








////////////////////////////////////////////////////////////////////////////////
//    divisor stuff
////////////////////////////////////////////////////////////////////////////////

proc makeDivisor(list #)
"USAGE: makeDivisor((Y1,m1)[,(Y2,m2),...],X); Y1,Y2,.. scheme , m1,m2,.. int , X scheme
RETURN: The divisor D=m1*[Y1]+m2*[Y2]+...
EXAMPLE: example makeDivisor; shows an example"
{
   def R=basering;
   if(typeof(#[size(#)])!="scheme")
   { ERROR("Last entry must a scheme")}
   scheme X=#[size(#)];
   
   divisor result;
   result.space=X;
   for(int i=1; i<=size(#)-1; i=i+1)
   {
      result.schemes[i]=#[i][1];
	  result.mults[i]=#[i][2];
   }
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(0);

scheme Y=makeProjScheme(ideal(x-z),X);
divisor A=list(Y,2),X;

Y=makeProjScheme(ideal(x2-zy),X);
scheme Z=makeProjScheme(ideal(x2z-z2y+y3),X);
divisor B=list(Y,1),list(Z,1),X;

Y=makeProjScheme(ideal(y),X);
divisor C=list(Y,1),X;

divisor D=A+3*B-C;
D.schemes;
D.mults;

divisor E=2*A-4*B;
E.schemes;
E.mults;

divisor F=D+E;
F.schemes;
F.mults;
}


// Addition of divisors
static proc AddDivisor(divisor C, divisor D)
{
    if(C.space!=D.space)
    {   ERROR("Divisors incompatible.");}
    
	def R=basering;
	divisor result=C;
	result.space=C.space;
	int i,k,check;
	for(i=1; i<=size(D.schemes); i=i+1)
	{
	   check=0;
	   k=1;
	   while((k<=size(result.schemes))&&(check==0))
	   {
	      if(D.schemes[i]==result.schemes[k])
		  {
		     check=1;
			 result.mults[k]=result.mults[k]+D.mults[i];
			 if(result.mults[k]==0)
			 {
			    result.schemes=delete(result.schemes,k);
				result.mults=delete(result.mults,k);
			 }
		  }
		  k=k+1;
	   }
	   
	   if(check==0)
	   {
	      result.schemes=result.schemes+list(D.schemes[i]);
		  result.mults=result.mults+list(D.mults[i]);
	   }
	}
	
	setring R;
	return(result);
}


// Substraction of divisors
static proc SubDivisor(divisor C, divisor D)
{
    divisor result=(-1)*D;
	result=result+C;
	return(result);
}


// Multiplication of a divisor with an integer
static proc intTimesDivisor(int n, divisor D)
{
    divisor result;
	result.space=D.space;
	if(n!=0)
	{
	result.schemes=D.schemes;
    for(int i=1; i<=size(D.schemes); i=i+1)
	{
	   result.mults[i]=n*D.mults[i];
	}}
	return(result);
}







////////////////////////////////////////////////////////////////////////////////
//    ratFunc stuff
////////////////////////////////////////////////////////////////////////////////

proc makeratFunc(poly num, list #)
"USAGE: makeratFunc(f[,g]); poly f,g
RETURN: rational function f/g, if no g is put in then g is set to 1 by default
EXAMPLE: example makeratFunc; creates an example"
{
ratFunc r;
r.in=basering;
if(size(#)==0)
{   
   r.num=num;
   r.den=1;
} else {
   if(#[1]==0)
   {   ERROR("Denominator cannot be 0!");}
   poly g=gcd(num,#[1]);
   g=g*leadcoef(#[1]);
   r.num=num/g;
   r.den=#[1]/g;
}
return(r);
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
ratFunc F=x2,xy;
F;
ratFunc G=x2+y3;
G;
ratFunc H=1,x;
H;

G+H-F;
F*G;
F^3;
F/G;

F==H;
1/(y*F)==H;
}

// Print routine for ratFunc
static proc printratFunc(ratFunc r)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   if(r.den==1)
   {
      string(r.num);   
   } else {
      string(r.num)+" / "+string(r.den);
   }
   setring R;
}


// Gives ratFunc as a string
static proc stringratFunc(ratFunc r)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   if(r.den==1)
   {
      string st=string(r.num);   
   } else {
      string st=string(r.num)+" / "+string(r.den);
   }
   setring R;
   return(st);
}


// Used for comparing ratFuncs
static proc equalratFunc(ratFunc r, ratFunc q)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   int requalq = (r.num*q.den)==(r.den*q.num);
   setring R;
   return(requalq);
}


// Used for comparing ratFuncs
static proc notequalratFunc(ratFunc F, ratFunc G)
{
   return(!equalratFunc(F,G));
}


// Multiplication of ratFuncs
static proc multratFunc(ratFunc r, ratFunc q)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   ratFunc rtimesq = r.num*q.num, r.den*q.den;
   setring R;
   return(rtimesq);
}


// Division of ratFuncs
static proc divideratFunc(ratFunc r, ratFunc q)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   ratFunc zero=0,1;
   if(q==zero)
   {  ERROR("Cannot divide by zero!!!")}
   ratFunc rdivq = r.num*q.den, r.den*q.num;
   setring R;
   return(rdivq);
}


// Addition of ratFuncs
static proc addratFunc(ratFunc r, ratFunc q)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   ratFunc rplusq = r.num*q.den+r.den*q.num, r.den*q.den;
   setring R;
   return(rplusq);
}


// Substraction of ratFuncs
static proc subratFunc(ratFunc r, ratFunc q)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   ratFunc rminusq = r.num*q.den-r.den*q.num, r.den*q.den;
   setring R;
   return(rminusq);
}


// Exponents of ratFuncs
static proc expratFunc(ratFunc r, int n)
{
   def R=basering;
   def SS=r.in;
   setring SS;
   ratFunc zero=0,1;
   ratFunc rexpn;
   if(n>=0)
   {
      rexpn=r.num^n,r.den^n;
   } else {
      if(r==zero)
	  {   ERROR("Negative exponent not allowed for 0!!!");}
	  rexpn=r.den^(-n),r.num^(-n);
   }
   setring R;
   return(rexpn);
}




////////////////////////////////////////////////////////////////////////////////
//   Composition stuff
////////////////////////////////////////////////////////////////////////////////


proc PolyCompratFunc(Poly F, list #)
"USAGE: PolyCompratFunc(F,r_1,...,r_n); F Poly, r_1,...,r_n ratFunc
ASSUME: r_1,...,r_n belong to the same ring and n=nvars(F.in)
RETURN: F(r_1,...,r_n)
EXAMPLE: example PolyCompratFunc; creates an example"
{
   def R=basering;
   def S=F.in;
   setring S;
   poly Fp=F.value;
   int n=size(#);
   if(n!=nvars(S))
   {   ERROR("Wrong number of arguments!!!");}
   
   list rl=ringlist(S);
   list newvars=list();
   for(int k=1; k<=n; k=k+1)
   {
	  newvars=newvars+list("x("+string(k)+")");
   }
   newvars=newvars+list("t");	 
   rl[2]=newvars;
   rl[3][1][2]=rl[3][1][2],1;
   def newS=ring(rl);
   setring newS;
   
   ideal I=var(1);
   for(k=2; k<=n; k=k+1)
   {
	  I=I,ideal(var(k));
   }
   map phi=S,I;
   poly f=phi(Fp);
   f=homog(f,t);
   int d=deg(f);
   
   def SS=#[1].in;
   setring SS;
   poly g=1;
   for(k=1; k<=n; k=k+1)
   {
	  g=g*#[k].den;
   }
   ideal J=(g/#[1].den)*#[1].num;
   for(k=2; k<=n; k=k+1)
   {
	  J=J,ideal((g/#[k].den)*#[k].num);
   }
   J=J,ideal(g);
   map psi=newS,J;
   ratFunc result=psi(f),g^d;
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
Poly F=x2-xy+y3;

ring S=0,(u,v,w),dp;
ratFunc r1=u,v;
ratFunc r2=w,u;

ratFunc G=PolyCompratFunc(F,r1,r2);
G;
}


proc ratFuncCompratFunc(ratFunc r, list #)
"USAGE: ratFuncCompratFunc(F,r_1,...,r_n); F ratFunc, r_1,...,r_n ratFunc
ASSUME: r_1,...,r_n belong to the same ring and n=nvars(F.in)
RETURN: F(r_1,...,r_n)
EXAMPLE: example ratFuncCompratFunc; creates an example"
{
   def R=basering;
   def S=r.in;
   setring S;
   if(size(#)!=nvars(S))
   {   ERROR("Wrong number of arguments!!!");}
   ratFunc result=PolyCompratFunc(r.num,#)/PolyCompratFunc(r.den,#);
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
ratFunc F=x2+y,x-y;

ring S=0,(u,v,w),dp;
ratFunc r1=u,v;
ratFunc r2=u+w,v-w;

ratFunc G=ratFuncCompratFunc(F,r1,r2);
G;
}



proc ChartmapCompIdeal(chartmap phi, Ideal I)
"USAGE: ChartmapCompIdeal(phi,I); phi chartmap, I ideal
ASSUME: I.in=phi.im.in
RETURN: Ideal defining the inverse image under phi of the closed subscheme defined by I
EXAMPLE: example ChartmapCompIdeal; creates an example"
{
   def R=basering;
   def S=phi.preim.in;
   def SS=phi.im.in;
   setring SS;
   int m=size(phi.ratFuncs);
   int n=size(I.value);
   int i,j;
   ratFunc r;
   list L,LL;
   Ideal II;
   for(i=1; i<=m; i=i+1)
   {
      setring SS;
      LL=list();
      for(j=1;j<=n;j=j+1)
      {
         r=PolyCompratFunc(I.value[j],phi.ratFuncs[i]);
	     LL=LL+list(r);
      }
      setring S;
      poly k=0;
      for(j=1;j<=n;j=j+1)
      {
         k=lcm(k,LL[j].den);
      }
      II=0;
      poly f;
      for(j=1;j<=n;j=j+1)
      {
         f=k/LL[j].den;
         II=II+ideal(f*LL[j].num);
      }
	  kill f,k;
      II.value=II.value+phi.preim.value;
      II=sat(II.value,phi.dom[i])[1];
      L[i]=II;
   }
   
   setring S;
   ideal J=1;
   Ideal result;
   for(i=1; i<=m; i=i+1)
   {
      J=intersect(J,L[i].value);
   }
   result=std(J);
   
   setring R;
   return(result);
}
example
{
ring R=0,(a,b,c,d),dp;
chart U=ideal(ad-bc,ac-bd);
Ideal Dom=ideal(c,d);
ratFunc F1=a,c;
ratFunc F2=b,c;
ratFunc G1=b,d;
ratFunc G2=a,d;
ring S=0,(x,y),dp;
chart V=0;
Ideal I=ideal(x,y);
chartmap phi=U,V,Dom,F1,F2,G1,G2;

Ideal J=ChartmapCompIdeal(phi,I);
J;
}



proc ChartmapCompChartmap(chartmap phi, chartmap psi)
{
   if(phi.preim.in!=psi.im.in)
   {   ERROR("Chartmaps not compatible");}
   
   def R=basering;
   def S=psi.preim.in;
   def SS=phi.preim.in;
   list Maps;
   int i,j,k;
   ratFunc G,F;
   setring S;
   ideal Dom;
   int l=1;
   for(i=1; i<=size(psi.ratFuncs); i=i+1)
   {
      for(j=1; j<=size(phi.ratFuncs); j=j+1)
      {
         setring SS;
         G=phi.dom[j];
         F=ratFuncCompratFunc(G,psi.ratFuncs[i]);
         setring S;
         Dom[l]=lcm(F.num,psi.dom[i]);
         for(k=1; k<=nvars(phi.im.in); k=k+1)
         {
            Maps=Maps+list(ratFuncCompratFunc(phi.ratFuncs[j][k],psi.ratFuncs[i]));
         }
		 l=l+1;
      }
   }
   
   chartmap result=psi.preim,phi.im,Dom,Maps;
   kill Dom;
   setring R;   
   return(result);
}
example
{
ring R=0,(a,b,c,d),dp;
chart U=ideal(ad-bc,ac-bd);
Ideal Dom1=ideal(c,d);
ratFunc F1=a,c;
ratFunc F2=b,c;
ratFunc F3=1;
ratFunc G1=b,d;
ratFunc G2=a,d;
ratFunc G3=1;

ring S=0,(x,y,z),dp;
chart V=xy-z2;
chartmap psi=U,V,Dom1,F1,F2,F3,G1,G2,G3;
Ideal Dom2=ideal(y,z);
ratFunc H1=z,y;
ratFunc H2=x,z;

ring T=0,(x),dp;
chart W=0;
chartmap phi=V,W,Dom2,H1,H2;

phi*psi;
}


proc chartmapImage(chartmap phi, list #)
"USAGE: chartmapImage(phi[,I]); phi chartmap, I Ideal
ASSUME: I lies in the ring of phi.preim
RETURN: Ideal J that, if no additional input given, represents the image of phi, 
        otherwise it represents the image of V(I) under phi
EXAMPLE: example chartmapImage; gives an example"
{
   def Base=basering;
   def R=phi.preim.in;
   def S=phi.im.in;
   Ideal result;
   int i,j,n,m,e,c;
   n=nvars(R);
   m=nvars(S);
   c=char(R);
   
   setring R;
   ideal A=phi.preim.value;
   if((size(#)==1)&&(typeof(#[1])=="ideal"))
   {
      A=A+#[1];
   }else{
   if((size(#)==1)&&(typeof(#[1])=="Ideal"))
   {
      if(#[1].in!=R)
	  {   ERROR(Rings incompatible!)}
	  A=A+#[1].value;
   }}
   
   setring S;
   ideal B=phi.im.value;
   result=makeIdeal(ideal(1));
   
   for(i=1; i<=size(phi.ratFuncs); i=i+1)
   {
      setring R;
	  poly p=phi.dom[i];
	  
      ring T=c,(t,x(1..n),y(1..m)),dp;
	  setring T;
	  ideal Ix,Iy,It;
	  for(j=1; j<=n; j=j+1)
	  {
	     Ix=Ix,x(j);
	  }
	  Ix=simplify(Ix,2);
	  map f=R,Ix;
	  kill Ix;
	  for(j=1; j<=m; j=j+1)
	  {
	     Iy=Iy,y(j);
	  }
	  Iy=simplify(Iy,2);
	  map g=S,Iy;
	  kill Iy;
	  It=ideal(f(p)*t-1);
	  
	  setring S;
	  ideal J,K;
	  for(j=1; j<=n+m+1; j=j+1)
	  {
	     if(j<=n+1)
		 {
		    J=J,1;
		 }else{
		    J=J,var(j-n-1);
		 }
	  }
	  J=simplify(J,2);
	  map h=T,J;
	  kill J;
	  
	  setring T;
	  ideal L=f(A)+g(B)+It;
	  
      for(j=1; j<=m; j=j+1)
      {
	     setring R;
         poly r,s,q;
		 r=phi.ratFuncs[i][j].num;
		 s=phi.ratFuncs[i][j].den;
		 
		 e=0;
		 while((p^e)%s!=0)
		 {
		    e=e+1;
		 }
		 q=(p^e)/s;
		 r=r*q;
		 
		 setring T;
		 L=L+ideal(y(j)-f(r)*t^e);
		 
		 setring R;
		 kill r,s,q;
      }
	  
	  setring T;
	  L=elim(L,1..n+1);
	  setring S;
	  K=h(L);
	  result.value=intersect(result.value,K);
	  
	  kill h;
	  setring R;
	  kill p;
	  setring S;
	  kill K;
	  setring T;
	  kill L,f,g;
	  kill T;
   }

   setring R;
   kill A;
   
   setring Base;
   return(result);
}




/////////////////////////////////////////////////////////////////////////////////////
//  Morphism Stuff
/////////////////////////////////////////////////////////////////////////////////////

proc makeMorphism(scheme Preim, scheme Im, list Maps)
"USAGE: makeMorphism(Preim,Im,Maps); Preim,Im schemes, Maps list
ASSUME: Maps contains lists of the form (phi,i,j), where i,j are integers and phi is a chartmap 
        from the Preim.cover[i] to Im.cover[j]
RETURN: morphism psi from Preim to Im such that psi.chartmaps[Maps[k][2]][Maps[k][3]]=Maps[k][1]
        for each k
EXAMPLE: example makeMorphism; gives an example"
{
   morphism result;
   def R=basering;
   
   result.preim=Preim;
   result.im=Im;
   
   int i,j,k;
   for(i=1; i<=size(Preim.cover); i=i+1)
   {
      result.chartmaps[i]=list();
	  for(j=1; j<=size(Im.cover); j=j+1)
      {
	     chartmap phi;
		 phi.preim=Preim.cover[i];
		 phi.im=Im.cover[j];
		 
		 def S=Preim.cover[i].in;
		 setring S;
		 phi.dom=ideal(0);
		 
		 result.chartmaps[i][j]=phi;
		 
		 kill S;
		 kill phi;
      }
   }
   
   for(k=1; k<=size(Maps); k=k+1)
   {
      i=Maps[k][2];
	  j=Maps[k][3];
      result.chartmaps[i][j]=Maps[k][1];
   }
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(xz-y2);
ring S=0,(a,b),dp;
scheme Y=makeProjScheme(0);

def T=X.cover[1].in;
setring T;
Ideal Dom=1;
ratFunc F=y;
chartmap phi=X.cover[1],Y.cover[1],Dom,F;
list L=list(list(phi,1,1));
kill T;

def T=X.cover[1].in;
setring T;
Dom=y;
F=1,y;
phi=X.cover[1],Y.cover[2],Dom,F;
L=L+list(list(phi,1,2));
kill T;

def T=X.cover[2].in;
setring T;
Dom=1;
F=z;
phi=X.cover[2],Y.cover[1],Dom,F;
L=L+list(list(phi,2,1));
kill T;

def T=X.cover[2].in;
setring T;
Dom=1;
F=x;
phi=X.cover[2],Y.cover[2],Dom,F;
L=L+list(list(phi,2,2));
kill T;

def T=X.cover[3].in;
setring T;
Dom=x;
F=y,x;
phi=X.cover[3],Y.cover[1],Dom,F;
L=L+list(list(phi,3,1));
kill T;

def T=X.cover[3].in;
setring T;
Dom=1;
F=y;
phi=X.cover[3],Y.cover[2],Dom,F;
L=L+list(list(phi,3,2));


morphism psi=X,Y,L;
psi.preim.cover;
psi.im.cover;
psi.chartmaps;
}



proc MorphismCompMorphism(morphism phi, morphism psi)
"USAGE: MorphismCompMorphism(phi,psi); phi,psi morphism
RETURN: Composition of phi with psi
EXAMPLE: example MorphismCompMorphism; gives an example"
{
   if(phi.preim!=psi.im)
   {
      ERROR("Inputs not compatible");
   }
   
   def R=basering;
   morphism result;
   
   result.preim=psi.preim;
   result.im=phi.im;
   
   int i,j,k,l;
   for(i=1; i<=size(psi.preim.cover); i=i+1)
   {
      result.chartmaps[i]=list();   
      for(j=1; j<=size(phi.im.cover); j=j+1)
      {
         chartmap f;
		 f.preim=psi.preim.cover[i];
		 f.im=phi.im.cover[j];
		 
		 def S=psi.preim.cover[i].in;
		 setring S;
		 f.dom=ideal(0);
		 
		 for(k=1; k<=size(phi.preim.cover); k=k+1)
		 {
		    chartmap g=phi.chartmaps[k][j]*psi.chartmaps[i][k];
			
			if(std(g.dom)!=0)
			{
			   f.dom=f.dom,g.dom;
			   f.dom=simplify(f.dom,2);
			   f.ratFuncs=f.ratFuncs+g.ratFuncs;
			}			
			
			kill g;
		 }
		 
		 k=1;
		 while(k<=size(f.dom))
		 {
		     poly p=f.dom[k];
			 l=1;
			 while(l<=size(f.dom))
			 {
			    if(k==l)
				{
				   l=l+1;
				}else{
				if(l<k)
				{
				   if(reduce(f.dom[l],p)==0)
				   {
				      f.dom=delete(f.dom,l);
					  f.ratFuncs=delete(f.ratFuncs,l);
					  k=k-1;
				   }else{
				      l=l+1;
				   }
				}else{
				   if(reduce(f.dom[l],p)==0)
				   {
				      f.dom=delete(f.dom,l);
					  f.ratFuncs=delete(f.ratFuncs,l);
				   }else{
				      l=l+1;
				   }
				}}
			 }
			 
			 k=k+1;
			 
			 kill p;
		 }
		 
		 result.chartmaps[i][j]=f;
		 
		 kill S;
		 kill f;
      } 
   }
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(xz-y2);
ring S=0,(a,b),dp;
scheme Y=makeProjScheme(0);

def T=X.cover[1].in;
setring T;
Ideal Dom=1;
ratFunc F=y;
chartmap f=X.cover[1],Y.cover[1],Dom,F;
list L=list(list(f,1,1));
kill T;

def T=X.cover[1].in;
setring T;
Dom=y;
F=1,y;
f=X.cover[1],Y.cover[2],Dom,F;
L=L+list(list(f,1,2));
kill T;

def T=X.cover[2].in;
setring T;
Dom=1;
F=z;
f=X.cover[2],Y.cover[1],Dom,F;
L=L+list(list(f,2,1));
kill T;

def T=X.cover[2].in;
setring T;
Dom=1;
F=x;
f=X.cover[2],Y.cover[2],Dom,F;
L=L+list(list(f,2,2));
kill T;

def T=X.cover[3].in;
setring T;
Dom=x;
F=y,x;
f=X.cover[3],Y.cover[1],Dom,F;
L=L+list(list(f,3,1));
kill T;

def T=X.cover[3].in;
setring T;
Dom=1;
F=y;
f=X.cover[3],Y.cover[2],Dom,F;
L=L+list(list(f,3,2));

morphism phi=X,Y,L;
kill T;


def T=Y.cover[1].in;
setring T;
Dom=1;
F=b;
ratFunc G=b2;
f=Y.cover[1],X.cover[1],Dom,F,G;
L=list(list(f,1,1));
kill T;

def T=Y.cover[1].in;
setring T;
Dom=b;
F=1,b;
G=b;
f=Y.cover[1],X.cover[2],Dom,F,G;
L=L+list(list(f,1,2));
kill T;

def T=Y.cover[1].in;
setring T;
Dom=b;
F=1,b2;
G=1,b;
f=Y.cover[1],X.cover[3],Dom,F,G;
L=L+list(list(f,1,3));
kill T;

def T=Y.cover[2].in;
setring T;
Dom=a;
F=1,a;
G=1,a2;
f=Y.cover[2],X.cover[1],Dom,F,G;
L=L+list(list(f,2,1));
kill T;

def T=Y.cover[2].in;
setring T;
Dom=a;
F=a;
G=1,a;
f=Y.cover[2],X.cover[2],Dom,F,G;
L=L+list(list(f,2,2));
kill T;

def T=Y.cover[2].in;
setring T;
Dom=1;
F=a2;
G=a;
f=Y.cover[2],X.cover[3],Dom,F,G;
L=L+list(list(f,2,3));

morphism psi=Y,X,L;

morphism id=psi*phi;
id.chartmaps;
}


proc isSameMap(def phi, def psi)
{
	if((typeof(phi)=="affRatMap")&&(typeof(psi)=="affRatMap"))
	{
	if((phi.preim!=psi.preim)||(size(phi.ratFuncs)!=size(psi.ratFuncs)))
	{
		return(0);
	}
	def B=basering;
	def R=phi.preim.in;
	setring R;
	poly p;
	for(int i=1; i<=size(phi.ratFuncs); i=i+1)
	{
		p=phi.ratFuncs[i].num*psi.ratFuncs[i].den-psi.ratFuncs[i].num*phi.ratFuncs[i].den;
		if(reduce(p,std(phi.preim.value))!=0)
		{
			setring B;
			return(0);
		}
	}
	setring B;
	return(1);
	}

	if((typeof(phi)=="projRatMap")&&(typeof(psi)=="projRatMap"))
	{
	if((phi.preim!=psi.preim)||(size(phi.ratFuncs)!=size(psi.ratFuncs)))
	{
		return(0);
	}
	def B=basering;
	def R=phi.preim.in;
	setring R;
	int n=size(phi.ratFuncs);
	matrix M[2][n];
	for(int i=1; i<=size(phi.ratFuncs); i=i+1)
	{
		M[1,i]=phi.ratFuncs[i].value;
		M[2,i]=psi.ratFuncs[i].value;
	}
	ideal I=minor(M,2);
	if(size(reduce(I,std(phi.preim.value)))!=0)
	{
		setring B;
		return(0);
	}
	setring B;
	return(1);
	}
}

static proc isnotSameMap(def phi, def psi)
{
	if((typeof(phi)=="affRatMap")&&(typeof(psi)=="affRatMap"))
	{
		return(!isSameMap(phi,psi));
	}
	if((typeof(phi)=="projRatMap")&&(typeof(psi)=="projRatMap"))
	{
		return(!isSameMap(phi,psi));
	}
}


proc affRatMapCompaffRatMap(affRatMap phi, affRatMap psi)
{
	affRatMap result;
	result.preim=psi.preim;
	result.im=phi.im;

	for(int i=1; i<=size(phi.ratFuncs); i=i+1)
	{
		result.ratFuncs[i]=ratFuncCompratFunc(phi.ratFuncs[i],psi.ratFuncs);
	}

	return(result);
}


proc projRatMapCompprojRatMap(projRatMap phi, projRatMap psi)
{
	def B=basering;
	def R=psi.preim.in;
	def S=psi.im.in;
	projRatMap result;
	result.preim=psi.preim;
	result.im=phi.im;

	setring S;
	ideal I=0;
	for(int i=1; i<=size(phi.ratFuncs); i=i+1)
	{
		I[i]=phi.ratFuncs[i].value;
	}

	setring R;
	ideal J=0;
	for(i=1; i<=size(psi.ratFuncs); i=i+1)
	{
		J[i]=psi.ratFuncs[i].value;
	}
	map f=S,J;
	J=f(I);
	poly g=0;
	for(i=1; i<=ncols(J); i=i+1)
	{
		g=gcd(g,J[i]);
	}
	Poly P;
	for(i=1; i<=ncols(J); i=i+1)
	{
		P=J[i]/g;
		result.ratFuncs[i]=P;
	}

	setring B;
	return(result);
}


proc ChartmapToMorphism(chartmap phi)
"USAGE: ChartmapToMorphism(phi); phi chartmap
RETURN: morphism corresponding to phi
EXAMPLE: example ChartmapToMorphism; gives an example"
{
   morphism result;
   
   result.preim=ChartToScheme(phi.preim);
   result.im=ChartToScheme(phi.im);
   result.chartmaps=list(list(phi));
   
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
chart U=0;
Ideal Dom=1;
list L=list(makeratFunc(x),makeratFunc(y),makeratFunc(1));
ring S=0,(a,b,c),dp;
chart V=0;
chartmap phi=U,V,Dom,L;

morphism Phi=ChartmapToMorphism(phi);
Phi.preim;
Phi.im;
Phi.chartmaps;
}


proc BlowUpMapToMorphism(blowUpMap phi)
"USAGE: BlowUpMapToMorphism(phi); phi blowUpMap
RETURN: morphism corresponding to phi
EXAMPLE: example BlowUpMapToMorphism; gives an example"
{
   morphism result=phi.blow,phi.base,list();
   
   int i,j;
   for(i=1; i<=size(phi.blow.cover); i=i+1)
   {
      j=phi.maps[i][2];
	  result.chartmaps[i][j]=phi.maps[i][1];
   }

   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(0);
scheme Z=makeProjScheme(ideal(x-z,y-z),X);

list L=blowUp(X,Z);

morphism Pi=BlowUpMapToMorphism(L[2]);
Pi.preim.cover;
Pi.im.cover;
Pi.chartmaps;
}



proc Domain(def phi)
{
	if(typeof(phi)=="affRatMap")
	{
		def R=basering;
		def S=phi.preim.in;
		setring S;
		int n=nvars(phi.im.in);
		Ideal Dom=ideal(1);
		ideal I=phi.preim.value;

		for(int i=1; i<=n; i=i+1)
		{
			poly f=phi.ratFuncs[i].num;
			poly g=phi.ratFuncs[i].den;
			ideal J=quotient(ideal(g)+I,ideal(f));
			Dom.value=intersect(Dom.value,J);

			kill f,g,J;
		}

		return(Dom);
		setring R;
	}else{
	if(typeof(phi)=="projRatMap")
	{
		def R=basering;
		def S=phi.preim.in;
		setring S;
		int n=nvars(phi.im.in);
		int m=nvars(S);
		int i;
		Ideal Dom=ideal(0);
		ideal I=phi.preim.value;
		ideal J=0;
		ideal Z=0;

		for(i=1; i<=n; i=i+1)
		{
			J=J+phi.ratFuncs[i].value;
		}

		for(i=1; i<=m; i=i+1)
		{
			Z=Z+ideal(var(i));
		}

		for(i=1; i<=n; i=i+1)
		{
			Dom.value=Dom.value+quotient(ideal(phi.ratFuncs[i].value)+I,J);
		}

		Dom.value=sat(Dom.value,Z)[1];
		return(Dom);
		setring R;
	}}
}




proc InvImage(def X, def phi)
"USAGE: InvImage(X,phi); X scheme, phi morphism
RETURN: Inverse image of X under phi
EXAMPLE: example InvImage; gives an example"
{
   if((typeof(X)=="scheme")&&(typeof(phi)=="morphism"))
   {
   def R=basering;
   scheme result;
   
   int i,j;
   for(i=1; i<=size(phi.preim.cover); i=i+1)
   {
      def S=phi.preim.cover[i].in;
	  setring S;
	  ideal I=1;
	  Ideal J;
      for(j=1; j<=size(phi.im.cover); j=j+1)
      {
	     def T=phi.im.cover[j].in;
		 setring S;
		 if(std(phi.chartmaps[i][j].dom)!=0)
		 {
		 setring T;
		 J=ChartmapCompIdeal(phi.chartmaps[i][j],X.cover[j].value);
		 setring S;
		 I=intersect(I,J.value);
		 }
		 
		 kill T;
      }
	  setring S;
	  I=std(I+phi.preim.cover[i].value);
	  chart U=I;
	  result.cover[i]=U;
	  
	  kill I;
	  kill J,S,U;
   }
   
   result.maps=phi.preim.maps;
   
   for(i=1; i<=size(result.cover); i=i+1)
   {
      for(j=1; j<=size(result.cover); j=j+1)
      {
	     result.maps[i][j].preim=result.cover[i];
		 result.maps[i][j].im=result.cover[j];
      }
   }
   
   setring R;
   return(result);
   }

   if((typeof(X)=="affVariety")&&(typeof(phi)=="affRatMap"))
   {
	def B=basering;
	def R=phi.preim.in;
	def S=phi.im.in;

	setring S;
	int i;
	list L;
	for(i=1; i<=ncols(X.value); i=i+1)
	{
		L=L+list(PolyCompratFunc(X.value[i],phi.ratFuncs));
	}

	setring R;
	poly p=1;
	for(i=1; i<=size(L); i=i+1)
	{
		p=lcm(p,L[i].den);
	}
	ideal I=phi.preim.value;
	for(i=1; i<=size(L); i=i+1)
	{
		I=I+ideal(L[i].num*p/L[i].den);
	}
	I=sat(I,Domain(phi).value)[1];
	affVariety result=I;
	return(result);
   }

   if((typeof(X)=="projVariety")&&(typeof(phi)=="projRatMap"))
   {
	def B=basering;
	def R=phi.preim.in;
	def S=phi.im.in;
	int i;

	setring S;
	ideal I=X.value;

	setring R;
	ideal P;
	for(i=1; i<=size(phi.ratFuncs); i=i+1)
	{
		P[i]=phi.ratFuncs[i].value;
	}
	map f=S,P;
	P=0;
	for(i=1; i<=nvars(R); i=i+1)
	{
		P[i]=var(i);
	}
	ideal J=f(I)+phi.preim.value;
	J=sat(J,Domain(phi).value*P)[1];

	projVariety result=J;
	return(result);
   }
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(xz-y2);
ring S=0,(a,b),dp;
scheme Y=makeProjScheme(0);

def T=X.cover[1].in;
setring T;
Ideal Dom=1;
ratFunc F=y;
chartmap f=X.cover[1],Y.cover[1],Dom,F;
list L=list(list(f,1,1));
kill T;

def T=X.cover[1].in;
setring T;
Dom=y;
F=1,y;
f=X.cover[1],Y.cover[2],Dom,F;
L=L+list(list(f,1,2));
kill T;

def T=X.cover[2].in;
setring T;
Dom=1;
F=z;
f=X.cover[2],Y.cover[1],Dom,F;
L=L+list(list(f,2,1));
kill T;

def T=X.cover[2].in;
setring T;
Dom=1;
F=x;
f=X.cover[2],Y.cover[2],Dom,F;
L=L+list(list(f,2,2));
kill T;

def T=X.cover[3].in;
setring T;
Dom=x;
F=y,x;
f=X.cover[3],Y.cover[1],Dom,F;
L=L+list(list(f,3,1));
kill T;

def T=X.cover[3].in;
setring T;
Dom=1;
F=y;
f=X.cover[3],Y.cover[2],Dom,F;
L=L+list(list(f,3,2));

morphism phi=X,Y,L;

setring S;
scheme Z=makeProjScheme(ideal(3a-2b),Y);

scheme Zinv=InvImage(Z,phi);
Zinv;
}


proc Graph(def phi)
{
	if(typeof(phi)=="affRatMap")
	{
		def B=basering;
		product result=makeProduct(phi.preim,phi.im);
		def S=phi.preim.in;
		int n=nvars(S);
		int i;

		def R=result.in;
		setring R;
		ideal I;

		for(i=1; i<=size(phi.ratFuncs); i=i+1)
		{
			setring S;
			poly p,q;
			p=phi.ratFuncs[i].num;
			q=phi.ratFuncs[i].den;

			setring R;
			poly p=fetch(S,p);
			poly q=fetch(S,q);
			I=I+ideal(p,q);
			result.value=result.value+ideal(q*var(n+i)-p);

			kill p,q;
			setring S;
			kill p,q;
		}
		setring R;
		result.value=sat(result.value,I)[1];

		kill I;
		kill n,i,S,R;
		setring B;
		return(result);
	}

	if(typeof(phi)=="projRatMap")
	{
		def B=basering;
		product result=makeProduct(phi.preim,phi.im);
		def S=phi.preim.in;
		int n=nvars(S);
		int i,j;

		def R=result.in;
		setring R;
		ideal I;

		for(i=1; i<size(phi.ratFuncs); i=i+1)
		{
		for(j=i+1; j<=size(phi.ratFuncs); j=j+1)
		{
			setring S;
			poly p,q;
			p=phi.ratFuncs[i].value;
			q=phi.ratFuncs[j].value;

			setring R;
			poly p=fetch(S,p);
			poly q=fetch(S,q);
			I=I+ideal(p,q);
			result.value=result.value+ideal(q*var(n+i)-p*var(n+j));

			kill p,q;
			setring S;
			kill p,q;
		}
		}
		setring R;
		result.value=sat(result.value,I)[1];

		kill I;
		kill n,i,j,S,R;
		setring B;
		return(result);
	}
}


proc Image(def phi, list #)
"USAGE: Image(phi[,Z]); phi morphism, Z scheme
ASSUME: Z is a subscheme of phi.preim
RETURN: scheme S that, if no additional input given, represents the image of phi, 
        otherwise it represents the image of Z under phi
EXAMPLE: example Image; gives an example"
{
   if(typeof(phi)=="morphism")
   {
   def B=basering;
   scheme result;
   int i,j;
   
   if(size(#)==0)
   {
      for(j=1; j<=size(phi.im.cover); j=j+1)
	  {
	     def R=phi.im.cover[j].in;
		 setring R;
		 ideal I=ideal(1);
		 Ideal J;
		 
		 for(i=1; i<=size(phi.preim.cover); i=i+1)
	     {
		    J=chartmapImage(phi.chartmaps[i][j]);
			I=intersect(I,J.value);
		 }
		 
		 I=I+phi.im.cover[j].value;
		 result.cover[j]=makeChart(I);
		 
		 kill J,I;
		 kill R;
	  }
   }else{
   if((size(#)==1)&&(typeof(#[1])=="scheme"))
   {
      for(j=1; j<=size(phi.im.cover); j=j+1)
	  {
	     def R=phi.im.cover[j].in;
		 setring R;
		 ideal I=ideal(1);
		 Ideal J;
		 
		 for(i=1; i<=size(phi.preim.cover); i=i+1)
	     {
		    def S=phi.preim.cover[i].in;
			setring S;
			
		    J=chartmapImage(phi.chartmaps[i][j],#[1].cover[i].value);
			setring R;
			I=intersect(I,J.value);
			
			kill S;
		 }
		 
		 I=I+phi.im.cover[j].value;
		 result.cover[j]=makeChart(I);
		 
		 kill J,I;
		 kill R;
	  }
   }}
   
   result.maps=phi.im.maps;
   setring B;
   return(result);
   
   }else{
   if(typeof(phi)=="affRatMap")
   {
	  def Base=basering;
      def R=phi.preim.in;
      def S=phi.im.in;
      affVariety result;
      int i,j,n,m,e,c;
      n=nvars(R);
      m=nvars(S);
      c=char(R);
   
      setring R;
      ideal A=phi.preim.value;
      if(size(#)==1)
      {  
	     A=A+#[1].value;
      }
   
      setring S;
      ideal B=phi.im.value;
   
         setring R;
	     poly p=1;
		 for(j=1; j<=m; j=j+1)
		 {
			p=p*phi.ratFuncs[j].den;
		 }
	  
         ring T=c,(t,x(1..n),y(1..m)),dp;
	     setring T;
	     ideal Ix,Iy,It;
	     for(j=1; j<=n; j=j+1)
	     {
	        Ix=Ix,x(j);
	     }
	     Ix=simplify(Ix,2);
	     map f=R,Ix;
	     kill Ix;
	     for(j=1; j<=m; j=j+1)
	     {
	        Iy=Iy,y(j);
	     }
	     Iy=simplify(Iy,2);
	     map g=S,Iy;
	     kill Iy;
	     It=ideal(f(p)*t-1);
	  
	     setring S;
	     ideal J,K;
	     for(j=1; j<=n+m+1; j=j+1)
	     {
	        if(j<=n+1)
		    {
		       J=J,1;
		    }else{
		       J=J,var(j-n-1);
		    }
	     }
	     J=simplify(J,2);
	     map h=T,J;
	     kill J;
	  
	     setring T;
	     ideal L=f(A)+It;
	  
         for(j=1; j<=m; j=j+1)
         {
	        setring R;
            poly r,s;
		    r=phi.ratFuncs[j].num;
		    s=phi.ratFuncs[j].den;
		 
		    setring T;
		    L=L+ideal(f(s)*y(j)-f(r));
		 
		    setring R;
		    kill r,s;
         }
	  
	     setring T;
	     L=elim(L,1..n+1);
	     setring S;
	     K=h(L)+B;
	     result=K;
	  
	     kill h;
	     setring R;
	     kill p;
	     setring S;
	     kill K;
	     setring T;
	     kill L,f,g;
	     kill T;      

      setring R;
      kill A;
   
      setring Base;
      return(result);

   }else{
   if(typeof(phi)=="projRatMap")
   {
      def Base=basering;
      def R=phi.preim.in;
      def S=phi.im.in;
      projVariety result;
      int i,j,n,m,e,c;
      n=nvars(R);
      m=nvars(S);
      c=char(R);
   
      setring R;
      ideal A=phi.preim.value;
      if(size(#)==1)
      {  
	     A=A+#[1].value;
      }
   
      setring S;
      ideal B=phi.im.value;
	  
         ring T=c,(x(1..n),y(1..m)),dp;
	     setring T;
	     ideal Ix,Iy;
	     for(j=1; j<=n; j=j+1)
	     {
	        Ix=Ix,x(j);
	     }
	     Ix=simplify(Ix,2);
	     map f=R,Ix;
	     kill Ix;
	     for(j=1; j<=m; j=j+1)
	     {
	        Iy=Iy,y(j);
	     }
	     Iy=simplify(Iy,2);
	     map g=S,Iy;
	     kill Iy;
	  
	     setring S;
	     ideal J,K;
	     for(j=1; j<=n+m; j=j+1)
	     {
	        if(j<=n)
		    {
		       J=J,1;
		    }else{
		       J=J,var(j-n);
		    }
	     }
	     J=simplify(J,2);
	     map h=T,J;
	     kill J;
	  
	     setring T;
	     ideal L=f(A);
		 matrix M[2][m];
		 ideal J=0;
	  
         for(j=1; j<=m; j=j+1)
         {
	        setring R;
            poly r;
		    r=phi.ratFuncs[j].value;
		 
		    setring T;
		    M[1,j]=y(j);
			M[2,j]=f(r);
			J=J+f(r);
		 
		    setring R;
		    kill r;
         }
	  
	     setring T;
		 L=L+minor(M,2);
		 L=sat(L,J)[1];
	     L=elim(L,1..n);
	     setring S;
	     K=h(L)+B;
	     result=K;
	  
	     kill h;
	     setring S;
	     kill K;
	     setring T;
	     kill L,f,g;
	     kill T;      

      setring R;
      kill A;
   
      setring Base;
      return(result);
   }}}
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
scheme X=makeProjScheme(0);
scheme Z=makeProjScheme(ideal(x-2y),X);
ring S=0,(a,b,c,d),dp;
scheme Y=makeProjScheme(0);

def T=X.cover[1].in;
setring T;
Ideal Dom=1;
ratFunc F1=y;
ratFunc F2=y2;
ratFunc F3=y3;
chartmap f=X.cover[1],Y.cover[1],Dom,F1,F2,F3;
list L=list(list(f,1,1));
kill T;

def T=X.cover[1].in;
setring T;
Dom=y;
F1=1,y;
F2=y;
F3=y2;
f=X.cover[1],Y.cover[2],Dom,F1,F2,F3;
L=L+list(list(f,1,2));
kill T;

def T=X.cover[1].in;
setring T;
Dom=y;
F1=1,y2;
F2=1,y;
F3=y;
f=X.cover[1],Y.cover[3],Dom,F1,F2,F3;
L=L+list(list(f,1,3));
kill T;

def T=X.cover[1].in;
setring T;
Dom=y;
F1=1,y3;
F2=1,y2;
F3=1,y;
f=X.cover[1],Y.cover[4],Dom,F1,F2,F3;
L=L+list(list(f,1,4));
kill T;

def T=X.cover[2].in;
setring T;
Dom=x;
F1=1,x;
F2=1,x2;
F3=1,x3;
f=X.cover[2],Y.cover[1],Dom,F1,F2,F3;
L=L+list(list(f,2,1));
kill T;

def T=X.cover[2].in;
setring T;
Dom=x;
F1=x;
F2=1,x;
F3=1,x2;
f=X.cover[2],Y.cover[2],Dom,F1,F2,F3;
L=L+list(list(f,2,2));
kill T;

def T=X.cover[2].in;
setring T;
Dom=x;
F1=x2;
F2=x;
F3=1,x;
f=X.cover[2],Y.cover[3],Dom,F1,F2,F3;
L=L+list(list(f,2,3));
kill T;

def T=X.cover[2].in;
setring T;
Dom=1;
F1=x3;
F2=x2;
F3=x;
f=X.cover[2],Y.cover[4],Dom,F1,F2,F3;
L=L+list(list(f,2,4));

morphism phi=X,Y,L;

scheme XIm=Image(phi);

scheme ZIm=Image(phi,Z);
}




proc Inverse(def phi)
{
	if(typeof(phi)=="affRatMap")
	{
	  def Base=basering;
      def R=phi.preim.in;
      def S=phi.im.in;
      affRatMap result;
	  result.im=phi.preim;
	  result.preim=phi.im;
      int i,j,n,m,e,c,k,isdone;
      n=nvars(R);
      m=nvars(S);
      c=char(R);
   
      setring R;
      ideal A=phi.preim.value;
   
      setring S;
      ideal B=phi.im.value;
   
         setring R;
	     poly p=1;
		 for(j=1; j<=m; j=j+1)
		 {
			p=p*phi.ratFuncs[j].den;
		 }
	  
         ring T=c,(t,x(1..n),y(1..m)),(dp(1),dp(n),dp(m));
	     setring T;
	     ideal Ix,Iy,It;
		 poly v=1;
	     for(j=1; j<=n; j=j+1)
	     {
	        Ix=Ix,x(j);
			v=v*x(j);
	     }
	     Ix=simplify(Ix,2);
	     map f=R,Ix;
	     kill Ix;
	     for(j=1; j<=m; j=j+1)
	     {
	        Iy=Iy,y(j);
	     }
	     Iy=simplify(Iy,2);
	     map g=S,Iy;
	     kill Iy;
	     It=ideal(f(p)*t-1);
	  
	     setring S;
	     ideal J,K;
	     for(j=1; j<=n+m+1; j=j+1)
	     {
	        if(j<=n+1)
		    {
		       J=J,1;
		    }else{
		       J=J,var(j-n-1);
		    }
	     }
	     J=simplify(J,2);
	     map h=T,J;
	     kill J;
	  
	     setring T;
	     ideal L=f(A)+It;
	  
         for(j=1; j<=m; j=j+1)
         {
	        setring R;
            poly r,s;
		    r=phi.ratFuncs[j].num;
		    s=phi.ratFuncs[j].den;
		 
		    setring T;
		    L=L+ideal(f(s)*y(j)-f(r));
		 
		    setring R;
		    kill r,s;
         }
	  
	     setring T;
		 ideal LL;
		 for(j=1; j<=n; j=j+1)
		 {
			LL=eliminate(L,v/x(j));
			k=1;
			isdone=0;
			while((k<=size(LL))&&(!isdone))
			{
				matrix C=coeffs(LL[k],x(j));
				if(nrows(C)==2)
				{
					poly r,s;
					r=-C[1,1];
					s=C[2,1];

					setring S;
					ratFunc F=h(r),h(s);
					result.ratFuncs=result.ratFuncs+list(F);
					kill F;

					setring T;
					kill r,s;
					isdone=1;
				}
				kill C;
				k=k+1;
			}
			if(!isdone)
			{
				ERROR("Input is not invertible!");
			}
		 }
	     setring S;
	  
	     kill h;
	     setring R;
	     kill p;
	     setring S;
	     setring T;
	     kill L,f,g;
	     kill T;      

      setring R;
      kill A;
   
      setring Base;
      return(result);
	}

	if(typeof(phi)=="projRatMap")
	{
	  def Base=basering;
      def R=phi.preim.in;
      def S=phi.im.in;
      projRatMap result;
	  result.im=phi.preim;
	  result.preim=phi.im;
      int i,j,n,m,e,c,k,isdone;
      n=nvars(R);
      m=nvars(S);
      c=char(R);
   
      setring R;
      ideal A=phi.preim.value;
   
      setring S;
      ideal B=phi.im.value;
	  
         ring T=c,(x(1..n),y(1..m)),(dp(n),dp(m));
	     setring T;
	     ideal Ix,Iy;
		 poly v=1;
	     for(j=1; j<=n; j=j+1)
	     {
	        Ix=Ix,x(j);
			v=v*x(j);
	     }
	     Ix=simplify(Ix,2);
	     map f=R,Ix;
	     kill Ix;
	     for(j=1; j<=m; j=j+1)
	     {
	        Iy=Iy,y(j);
	     }
	     Iy=simplify(Iy,2);
	     map g=S,Iy;
	     kill Iy;
	  
	     setring S;
	     ideal J,K;
	     for(j=1; j<=n+m; j=j+1)
	     {
	        if(j<=n)
		    {
		       J=J,1;
		    }else{
		       J=J,var(j-n);
		    }
	     }
	     J=simplify(J,2);
	     map h=T,J;
	     kill J;
	  
	     setring T;
	     ideal L=f(A);
		 matrix M[2][m];
		 ideal J=0;
	  
         for(j=1; j<=m; j=j+1)
         {
	        setring R;
            poly r;
		    r=phi.ratFuncs[j].value;
		 
		    setring T;
		    M[1,j]=y(j);
			M[2,j]=f(r);
			J=J+f(r);
		 
		    setring R;
		    kill r;
         }
	  
	     setring T;
		 L=L+minor(M,2);
		 L=sat(L,J)[1];
		 kill M;

		 k=1;
		 isdone=0;
		 while((k<=n)&&(!isdone))
		 {
			if(reduce(x(k),L)!=0)
			{
				e=k;
				isdone=1;
			}
			k=k+1;
		 }
		 if(!isdone)
		 {
			ERROR("Input is not invertible");
		 }

		 ideal LL;
		 matrix M[2][n];
		 for(j=1; j<=n; j=j+1)
		 {
			if(j!=e)
			{
				LL=eliminate(L,v/(x(j)*x(e)));
			    k=1;
			    isdone=0;
			    while((k<=size(LL))&&(!isdone))
			    {
				   matrix C=coeffs(LL[k],x(e));
				   if(nrows(C)==1)
				   {
					   M[1,j]=0;
					   poly r=C[1,1];
					   C=coeffs(r,x(j));
					   if(nrows(C)==2)
					   {
						  M[2,j]=C[2,1];
						  isdone=1;
					   }
					   kill r;
				   }
				   if((nrows(C)==2))
				   {
				   if(C[2,1]/x(j)==0)
				   {
					   M[1,j]=-C[2,1];
					   poly r=C[1,1];
					   C=coeffs(r,x(j));
					   if(nrows(C)==2)
					   {
						  M[2,j]=C[2,1];
						  isdone=1;
					   }
					   kill r;
				   }}
				   kill C;
				   k=k+1;
			    }
			    if(!isdone)
			    {
				   ERROR("Input is not invertible!");
			    }
			}
			if(j==e)
			{
				M[1,e]=1;
				M[2,e]=1;
			}
		 }

	     setring S;
		 matrix M=h(M);
		 poly r=1;
		 for(j=1; j<=n; j=j+1)
		 {
			r=lcm(r,M[2,j]);
		 }
		 Poly F;
		 for(j=1; j<=n; j=j+1)
		 {
			F=r/M[2,j]*M[1,j];
			result.ratFuncs=result.ratFuncs+list(F);
		 }
	  
	     kill h;
	     setring S;
	     kill K;
	     setring T;
	     kill L,f,g;
	     kill T;      

      setring R;
      kill A;
   
      setring Base;
      return(result);
	}

	if(typeof(phi)=="chartmap")
	{
	def Base=basering;
    def R=phi.preim.in;
    def S=phi.im.in;
    chartmap result;
	result.im=phi.preim;
	result.preim=phi.im;
    int i,j,n,m,e,c,k,isdone;
    n=nvars(R);
    m=nvars(S);
    c=char(R);
   
    setring R;
    ideal A=phi.preim.value;
	ideal D=phi.dom;
   
    if(D==0)
	{
		setring S;
		result.dom=ideal(0);
	}else{
        setring S;
        ideal B=phi.im.value;
	  
        ring T=c,(x(1..n),y(1..m)),(dp(n),dp(m));
	    setring T;
	    ideal Ix,Iy;
		poly v=1;
	    for(j=1; j<=n; j=j+1)
	    {
	    	Ix=Ix,x(j);
			v=v*x(j);
	    }
	    Ix=simplify(Ix,2);
	    map f=R,Ix;
	    kill Ix;
	    for(j=1; j<=m; j=j+1)
	    {
	        Iy=Iy,y(j);
	    }
	    Iy=simplify(Iy,2);
	    map g=S,Iy;
	    kill Iy;
	  
	    setring S;
	    ideal J,K;
	    for(j=1; j<=n+m; j=j+1)
	    {
	        if(j<=n)
		    {
		       J=J,1;
		    }else{
		       J=J,var(j-n);
		    }
	    }
	    J=simplify(J,2);
	    map h=T,J;
	    kill J;
	  
	    setring T;
	    ideal L=f(A)+g(B);
	  
        for(j=1; j<=m; j=j+1)
        {
	        setring R;
            poly r,s;
		    r=phi.ratFuncs[1][j].num;
		    s=phi.ratFuncs[1][j].den;
		 
		    setring T;
		    L=L+ideal(f(s)*y(j)-f(r));
		 
		    setring R;
		    kill r,s;
        }
	  
	    setring T;
		L=sat(L,f(D))[1];
		ideal LL;
		list RF;
		for(j=1; j<=n; j=j+1)
		{
			LL=eliminate(L,v/x(j));
			k=1;
			isdone=0;
			while((k<=size(LL))&&(!isdone))
			{
				matrix C=coeffs(LL[k],x(j));
				if(nrows(C)==2)
				{
					poly r,s;
					r=-C[1,1];
					s=C[2,1];

					setring S;
					ratFunc F=h(r),h(s);
					RF=RF+list(F);
					kill F;

					setring T;
					kill r,s;
					isdone=1;
				}
				kill C;
				k=k+1;
			}
			if(!isdone)
			{
				ERROR("Input is not invertible!");
			}
		}
		
		setring S;
		ideal Dom=ideal(1);
		for(i=1; i<=n; i=i+1)
		{
			Dom=intersect(Dom,quotient(ideal(RF[i].den)+B,ideal(RF[i].num)));
		}

		result.dom=Dom;
		for(i=1; i<=size(Dom); i=i+1)
		{
			result.ratFuncs[i]=list();
			poly p=Dom[i];
			poly q;
			ideal I;
			for(j=1; j<=n; j=j+1)
			{
				I=RF[j].den,B;
				q=division(p*RF[j].num,I)[1][1,1];
				result.ratFuncs[i][j]=makeratFunc(q,p);
			}

			kill p,q,I;
		}	  

	    kill h,Dom,B,K;
	    setring T;
	    kill L,f,g;
	    kill T; 
		kill RF;
	}	      

    setring R;
    kill A,D;
   
    setring Base;
    return(result);
	}

	if(typeof(phi)=="morphism")
	{
		morphism result;
		result.preim=phi.im;
		result.im=phi.preim;
		int i,j;

		for(i=1; i<=size(phi.im.cover); i=i+1)
		{
			result.chartmaps[i]=list();
			for(j=1; j<=size(phi.preim.cover); j=j+1)
			{
				result.chartmaps[i][j]=Inverse(phi.chartmaps[j][i]);
			}
		}

		return(result);
	}
}





////////////////////////////////////////////////////////////////////////////////////
//    Blow-Up
////////////////////////////////////////////////////////////////////////////////////

proc blowUp(scheme X, scheme C)
"USAGE: blowUp(X,C);  X,C scheme
ASSUME: C is a subscheme of X
RETURN: return a list l=(B,pi,E),
          B scheme, is the blow-up of X in the center C
		  pi blowUpMap, is the map corresponding to the blow-up and contains all the relevant information
          E scheme, is the exeptional divisor of the blow-up
EXAMPLE: example blowUp;  shows an example
"             
{
   scheme B;
   blowUpMap pi;
   scheme E;
   list Bcover=list();
   list maps=list();
   list eD=list();
	
   pi.base=X;
   for(int i=1; i<=size(C.cover); i=i+1)
   {
       def S=C.cover[i].in;
	   setring S;
	   C.cover[i].value=std(C.cover[i].value);
	   kill S;
   }
   pi.center=C;
   
   // Computation of the Charts of the blow up

   int n=size(X.cover);
   for(i=1; i<=n; i=i+1)
   {
      def R=X.cover[i].in;
	  setring R;
	  int m=nvars(R);
	  C.cover[i].value=simplify(C.cover[i].value,2);
	  int l=size(C.cover[i].value);
	  ideal A=C.cover[i].value;
	  ideal Base=X.cover[i].value;
	  for(int j=1; j<=l; j=j+1)
	  {
		 def S=changevar("x()");
		 
		 list newvars;
		 for(int k=1; k<=l; k=k+1)
		 {
		    if(k!=j)
		    {   newvars=newvars+list("y("+string(k)+")");}
		 }
		 if(size(newvars)!=0)
		 {
			S=addvarsTo(S,newvars,0);
		 }
		 
		 setring S;
		 chart U=ideal(0);
		 chartmap phi;
		 phi.preim=U;
		 phi.im=X.cover[i];
		 phi.dom=1;
		 phi.ratFuncs[1]=list();
		 for(k=1; k<=m; k=k+1)
		 {
		    ratFunc r=var(k);
		    phi.ratFuncs[1]=phi.ratFuncs[1]+list(r);
			kill r;
		 }
		 
		 
		 
		 setring S;
		 ideal I=0;
		 ideal J=0;
		 for(k=1; k<=m; k=k+1)
		 {
		    I=I+ideal(var(k));
		 }
		 map f=R,I;
		 J=f(A);
		 I=f(Base);
		 for(k=1; k<=l; k=k+1)
		 {
		    if(k!=j)
			{
			   I=I+ideal(J[j]*y(k)-J[k]);
			}
		 }
		 I=sat(I,ideal(J[j]))[1];
		 U.value=I;
		 phi.preim=U;
		 Bcover=Bcover+list(U);
		 maps=maps+list(list(phi,i,j));
		 eD=eD+list(makeChart(std(U.value+J)));
		 
		 
		 kill J,newvars,S,I,U,phi,k;
		 setring R;
	  }
	  
	  kill R,m,l,j;
   }

   // Computation of the gluing maps of the blow up
   
   pi.maps=maps;
   B.cover=Bcover;
   int m=size(B.cover);
   int j,r,s,k,l,ll,e,kPreim,kIm,ny,nx,nn;
   list L,facts;
   ring R;
   for(i=1; i<=m; i=i+1)
   {
      L=list();
      for(j=1; j<=m; j=j+1)
	  {
		 kPreim=maps[i][3];
	     kIm=maps[j][3];
	     r=maps[i][2];
		 s=maps[j][2];
		 if(r!=s)
         {
		    chartmap phi;
			phi.preim=B.cover[i];
			phi.im=B.cover[j];
			
			chartmap psi=X.maps[r][s];
			def S=X.cover[r].in;
			def SS=X.cover[s].in;
			def T=B.cover[i].in;
			def TT=B.cover[j].in;
			
			setring T;
			ideal I;
			for(k=1; k<=nvars(S); k=k+1)
			{
			   I[k]=x(k);
			}
			map g=S,I;
			phi.dom=ideal();
			kill I;
			
			setring S;
			poly f,p,q;
			for(k=1; k<=size(psi.dom); k=k+1)
			{
			   facts=list();
			   f=psi.dom[k];
			   e=sat(C.cover[r].value,ideal(f))[2];
			   setring SS;
			   for(l=1; l<=size(C.cover[s].value); l=l+1)
			   {
			      facts[l]=list();
			      ratFunc F=PolyCompratFunc(makePoly(C.cover[s].value[l]),psi.ratFuncs[k]);
				  setring S;
				  list LL=pdivi(F.num*f^e,C.cover[r].value);
				  nn=size(C.cover[r].value);
				  for(ll=1; ll<=nn; ll=ll+1)
				  {
				     p=LL[2][ll];
					 setring T;
				     facts[l][ll]=makePoly(g(p));
					 setring S;
				  }
				  kill LL;
				  setring S;
				  p=F.den*f^e;
				  setring T;
				  facts[l][nn+1]=makePoly(g(p));
				  
				  kill F;
				  setring SS;
			   }
			   
			   setring T;
			   ratFunc F,G;
			   poly pt;
			   for(l=1; l<=size(facts[kIm])-1; l=l+1)
			   {
				  if(l!=kPreim)
				  {
				  pt=pt+facts[kIm][l].value*y(l);
				  }else{
				  pt=pt+facts[kIm][l].value;
				  }				  
			   }
			   pt=pt*g(f);
			   phi.dom[k]=pt;
			   phi.ratFuncs[k]=list();
			   F=pt,facts[kIm][size(facts[kIm])].value;
			   kill pt;
			   
			   for(l=1; l<=nvars(SS); l=l+1)
			   {
			      G=ratFuncCompratFunc(psi.ratFuncs[k][l],maps[i][1].ratFuncs[1]);
				  phi.ratFuncs[k]=phi.ratFuncs[k]+list(G);
			   }
			   
			   for(l=1; l<=size(facts); l=l+1)
			   {
			      if(l!=kIm)
				  {
			      G=0;
				  for(ll=1; ll<=size(facts[l])-1; ll=ll+1)
				  {
				     if(ll!=kPreim)
					 {
					 G=G+makeratFunc(facts[l][ll].value*y(ll),facts[l][size(facts[l])].value);
					 }else{
					 G=G+makeratFunc(facts[l][ll].value,facts[l][size(facts[l])].value);
					 }
				  }
				  phi.ratFuncs[k]=phi.ratFuncs[k]+list(G/F);
				  }
			   }
			   
			   kill F,G;
			   setring S;
			}

			L=L+list(phi);
			
			setring S;
			kill f,p,q;
			
			setring T;
			kill g;
			
			setring R;
			kill phi,psi,S,SS,T,TT;
		 }
		 else
		 {
			def S=X.cover[r].in;
			nx=nvars(S);
			
			def T=B.cover[i].in;
			chartmap phi;
			phi.preim=B.cover[i];
			phi.im=B.cover[j];
			setring T;
			phi.ratFuncs[1]=list();
			if(kPreim==kIm)
			{
			   phi.dom=1;
			   for(k=1;k<=nx;k=k+1)
			   {
			       ratFunc q=x(k);
				   phi.ratFuncs[1]=phi.ratFuncs[1]+list(q);
				   kill q;
			   }
			   ny=nvars(T)-nx+1;
			   for(k=1;k<=ny;k=k+1)
			   {
			       if(k!=kPreim)
				   {
			          ratFunc q=y(k);
				      phi.ratFuncs[1]=phi.ratFuncs[1]+list(q);
					  kill q;
				   }
			   }
			}else{
			   phi.dom=y(kIm);
			   for(k=1;k<=nx;k=k+1)
			   {
			       ratFunc q=x(k);
				   phi.ratFuncs[1]=phi.ratFuncs[1]+list(q);
				   kill q;
			   }
			   ny=nvars(T)-nx+1;
			   for(k=1;k<=ny;k=k+1)
			   {
			       if(k!=kIm)
				   {
				      if(k!=kPreim){
			          ratFunc q=y(k),y(kIm);
					  }else{
					  ratFunc q=1,y(kIm);
					  }
					  phi.ratFuncs[1]=phi.ratFuncs[1]+list(q);
					  kill q;
				   }
			   }
			}
			
			L=L+list(phi);
			kill S,T,phi;
			setring R;
		 }
	  }
	  B.maps=B.maps+list(L);
   }

   // Elimination of variables

   for(i=1; i<=size(B.cover); i=i+1)
   {
	  def S=B.cover[i].in;
	  setring S;
	  ideal I=B.cover[i].value;
	  ideal Ie=eD[i].value;
	  list elim=elimpart(I);
	  ideal Id=elim[5];
	  n=size(elim[2]);
	  if(n>0)
	  {
		 chartmap phi,psi;
		 phi.im=B.cover[i];
		 psi.preim=B.cover[i];
		 psi.dom=1;
		 psi.ratFuncs[1]=list();
		 for(j=1; j<=nvars(S); j=j+1)
		 {
			if(elim[4][j]!=0)
			{   
				psi.ratFuncs[1]=psi.ratFuncs[1]+list(makeratFunc(var(j)));
			}
		 }
		 def T=tolessvars(elim[4]);

		 setring T;
		 ideal Im=imap(S,Id);
		 map f=S,Im;
		 ideal J=std(f(I));
		 ideal Je=std(f(Ie));
		 chart U=J;
		 chart Ue=Je;
		 phi.preim=U;
		 psi.im=U;
		 phi.dom=1;
		 phi.ratFuncs[1]=list();
		 for(j=1; j<=nvars(S); j=j+1)
		 {
			phi.ratFuncs[1]=phi.ratFuncs[1]+list(makeratFunc(Im[j]));
		 }

		 B.cover[i]=U;
		 eD[i]=Ue;
		 for(j=1; j<=size(B.cover); j=j+1)
		 {
			B.maps[i][j]=B.maps[i][j]*phi;
			B.maps[j][i]=psi*B.maps[j][i];
		 }

		 kill f,J,Je,Im;
		 kill T,phi,psi,U,Ue;
	  }

	  setring S;
	  kill I,Ie,Id,elim;
	  kill S;
   }

   // Computation of the exceptional divisor
  
   E.cover=eD;
   E.maps=B.maps;
   for(i=1; i<=size(E.cover); i=i+1)
   {
	  for(j=1; j<=size(E.cover); j=j+1)
	  {
			E.maps[i][j].preim=E.cover[i];
			E.maps[i][j].im=E.cover[j];
	  }
   }
   
   pi.blow=B;
   pi.exDiv=E;
   return(list(B,pi,E));   
}
example
{ "EXAMPLE";
   ring R=0,(x,y,z),dp;
   scheme X=makeProjScheme(ideal(0));
   scheme Y=makeProjScheme(ideal(x-z,y-z),X);
   list L=blowUp(X,Y);
   
   "Affine cover of the blow-up";
   L[1].cover;
   
   "Maps between the affine charts";
   L[1].maps;
   
   "Exeptional divisor";
   L[3].cover;
}



proc itblowUp(def X, def C)
{
	if((typeof(X)=="iterativeScheme")&&(typeof(C)=="iterativeScheme"))
	{
	iterativeScheme B;
	B.maps=X.maps;
	coherentSheaf eD;
	int i;

	// Computation of the blowup charts

	int n=size(X.cover);
    for(i=1; i<=n; i=i+1)
    {
    	def R=X.cover[i].entry.in;
		setring R;
		int m=nvars(R);
		C.cover[i].entry.value=std(C.cover[i].entry.value);
		int l=size(C.cover[i].entry.value);
		ideal A=C.cover[i].entry.value;
		ideal Base=X.cover[i].entry.value;
		for(int j=1; j<=l; j=j+1)
		{
			def S=changevar("x()");
		 
			list newvars;
			for(int k=1; k<=l; k=k+1)
			{
		    	if(k!=j)
		    	{   newvars=newvars+list("y("+string(k)+")");}
		 	}
		 	if(size(newvars)!=0)
		 	{
				S=addvarsTo(S,newvars,0);
		 	}
		 
		 	setring S;
		 	chart U=ideal(0);
		 	chartmap phi;
		 	phi.preim=U;
		 	phi.im=X.cover[i].entry;
		 	phi.dom=1;
		 	phi.ratFuncs[1]=list();
		 	for(k=1; k<=m; k=k+1)
		 	{
		    	ratFunc r=var(k);
		    	phi.ratFuncs[1]=phi.ratFuncs[1]+list(r);
				kill r;
		 	}
		 
		 
		 	setring S;
		 	ideal I=0;
		 	ideal J=0;
		 	for(k=1; k<=m; k=k+1)
		 	{
		    	I=I+ideal(var(k));
		 	}
		 	map f=R,I;
		 	J=f(A);
		 	I=f(Base);
		 	for(k=1; k<=l; k=k+1)
		 	{
		    	if(k!=j)
				{
			   		I=I+ideal(J[j]*y(k)-J[k]);
				}
		 	}
		 	I=sat(I,ideal(J[j]))[1];
		 	U.value=I;
		 	phi.preim=U;

			chartmap psi;
			psi.preim=X.cover[i].entry;
			psi.im=U;
			setring R;
			psi.dom=ideal(A[j]);
			psi.ratFuncs[1]=list();
			for(k=1; k<=m; k=k+1)
		 	{
		    	ratFunc r=var(k);
		    	psi.ratFuncs[1]=psi.ratFuncs[1]+list(r);
				kill r;
		 	}
			for(k=1; k<=l; k=k+1)
		 	{
		    	if(k!=j)
				{
					ratFunc r=A[k],A[j];
		    		psi.ratFuncs[1]=psi.ratFuncs[1]+list(r);
					kill r;
				}
		 	}

			iterativeChart V;
			intvec v=X.cover[i].label;
			V.entry=U;
			V.parent=X.cover[i];
			V.parentmap=phi;
			V.parentInverseMap=psi;
			V.label=v,j;

			setring S;
			eD.cover=eD.cover+list(makeChart(U.value+J));
			B.cover=B.cover+list(V);
		 

		 	kill J,newvars,S,I,U,phi,k,V,v,psi;
		 	setring R;
	  	}

		kill A,Base;
	  	kill R,m,l,j;
   	}

	// Elimination of variables

	for(i=1; i<=size(B.cover); i=i+1)
   	{
		int j;
	  	def S=B.cover[i].entry.in;
	  	setring S;
	  	ideal I=B.cover[i].entry.value;
	  	ideal Ie=eD.cover[i].value;
	  	list elim=elimpart(I);
	  	ideal Id=elim[5];
	  	n=size(elim[2]);
	  	if(n>0)
	  	{
		 	chartmap phi,psi;
		 	phi.im=B.cover[i].entry;
		 	psi.preim=B.cover[i].entry;
		 	psi.dom=1;
		 	psi.ratFuncs[1]=list();
		 	for(j=1; j<=nvars(S); j=j+1)
		 	{
				if(elim[4][j]!=0)
				{   
					psi.ratFuncs[1]=psi.ratFuncs[1]+list(makeratFunc(var(j)));
				}
		 	}
		 	def T=tolessvars(elim[4]);

		 	setring T;
		 	ideal Im=imap(S,Id);
		 	map f=S,Im;
		 	ideal J=std(f(I));
		 	ideal Je=std(f(Ie));
		 	chart U=J;
		 	chart Ue=Je;
		 	phi.preim=U;
		 	psi.im=U;
		 	phi.dom=1;
		 	phi.ratFuncs[1]=list();
		 	for(j=1; j<=nvars(S); j=j+1)
		 	{
				phi.ratFuncs[1]=phi.ratFuncs[1]+list(makeratFunc(Im[j]));
		 	}

		 	B.cover[i].entry=U;
		 	eD.cover[i]=Ue;
			B.cover[i].parentmap=B.cover[i].parentmap*phi;
			B.cover[i].parentInverseMap=psi*B.cover[i].parentInverseMap;

		 	kill f,J,Je,Im;
		 	kill T,phi,psi,U,Ue;
	  	}

	  	setring S;
	  	kill I,Ie,Id,elim,j;
	  	kill S;
   	}

	kill i;
	return(list(B,eD));
	}

	if((typeof(X)=="iterativeChart")&&(typeof(C)=="iterativeChart"))
	{
	list B;
	int i,n;

	// Computation of the blowup charts

    	def R=X.entry.in;
		setring R;
		int m=nvars(R);
		C.entry.value=std(C.entry.value);
		int l=size(C.entry.value);
		ideal A=C.entry.value;
		ideal Base=X.entry.value;
		for(int j=1; j<=l; j=j+1)
		{
			def S=changevar("x()");
		 
			list newvars;
			for(int k=1; k<=l; k=k+1)
			{
		    	if(k!=j)
		    	{   newvars=newvars+list("y("+string(k)+")");}
		 	}
		 	if(size(newvars)!=0)
		 	{
				S=addvarsTo(S,newvars,0);
		 	}
		 
		 	setring S;
		 	chart U=ideal(0);
		 	chartmap phi;
		 	phi.preim=U;
		 	phi.im=X.entry;
		 	phi.dom=1;
		 	phi.ratFuncs[1]=list();
		 	for(k=1; k<=m; k=k+1)
		 	{
		    	ratFunc r=var(k);
		    	phi.ratFuncs[1]=phi.ratFuncs[1]+list(r);
				kill r;
		 	}
		 
		 
		 	setring S;
		 	ideal I=0;
		 	ideal J=0;
		 	for(k=1; k<=m; k=k+1)
		 	{
		    	I=I+ideal(var(k));
		 	}
		 	map f=R,I;
		 	J=f(A);
		 	I=f(Base);
		 	for(k=1; k<=l; k=k+1)
		 	{
		    	if(k!=j)
				{
			   		I=I+ideal(J[j]*y(k)-J[k]);
				}
		 	}
		 	I=sat(I,ideal(J[j]))[1];
		 	U.value=I;
		 	phi.preim=U;

			chartmap psi;
			psi.preim=X.entry;
			psi.im=U;
			setring R;
			psi.dom=ideal(A[j]);
			psi.ratFuncs[1]=list();
			for(k=1; k<=m; k=k+1)
		 	{
		    	ratFunc r=var(k);
		    	psi.ratFuncs[1]=psi.ratFuncs[1]+list(r);
				kill r;
		 	}
			for(k=1; k<=l; k=k+1)
		 	{
		    	if(k!=j)
				{
					ratFunc r=A[k],A[j];
		    		psi.ratFuncs[1]=psi.ratFuncs[1]+list(r);
					kill r;
				}
		 	}

			intvec v=X.label;
			iterativeChart V;
			V.entry=U;
			V.parent=X;
			V.parentmap=phi;
			V.parentInverseMap=psi;
			V.label=v,j;

			setring S;
			B=B+list(V);
		 

		 	kill J,newvars,S,I,U,phi,k,v,V,psi;
		 	setring R;
	  	}

		kill A,Base;
	  	kill R,m,l,j;
   	

	// Elimination of variables

	for(i=1; i<=size(B); i=i+1)
   	{
		int j;
	  	def S=B[i].entry.in;
	  	setring S;
	  	ideal I=B[i].entry.value;
	  	list elim=elimpart(I);
	  	ideal Id=elim[5];
	  	n=size(elim[2]);
	  	if(n>0)
	  	{
		 	chartmap phi,psi;
		 	phi.im=B[i].entry;
		 	psi.preim=B[i].entry;
		 	psi.dom=1;
		 	psi.ratFuncs[1]=list();
		 	for(j=1; j<=nvars(S); j=j+1)
		 	{
				if(elim[4][j]!=0)
				{   
					psi.ratFuncs[1]=psi.ratFuncs[1]+list(makeratFunc(var(j)));
				}
		 	}
		 	def T=tolessvars(elim[4]);

		 	setring T;
		 	ideal Im=imap(S,Id);
		 	map f=S,Im;
		 	ideal J=std(f(I));
		 	chart U=J;
		 	phi.preim=U;
		 	psi.im=U;
		 	phi.dom=1;
		 	phi.ratFuncs[1]=list();
		 	for(j=1; j<=nvars(S); j=j+1)
		 	{
				phi.ratFuncs[1]=phi.ratFuncs[1]+list(makeratFunc(Im[j]));
		 	}

		 	B[i].entry=U;
			B[i].parentmap=B[i].parentmap*phi;
			B[i].parentInverseMap=psi*B[i].parentInverseMap;

		 	kill f,J,Im;
		 	kill T,phi,psi,U;
	  	}

	  	setring S;
	  	kill I,Id,elim,j;
	  	kill S;
   	}

	kill i;
	return(B);
	}
}


proc strictTransform(Y,blowUpMap pi)
"USAGE: strinctTransform(Y,pi); 
RETURN: the strict transform of subscheme Y under the blow-up map pi
EXAMPLE: example strictTransform, shows an example"
{
   if(typeof(Y)=="scheme")
   {
      def B=basering;
      scheme result;
	  result.maps=pi.blow.maps;
      int n=size(pi.blow.cover);
	  for(int k=1; k<=n; k=k+1)
	  {
	     int m=pi.maps[k][2];
		 def R=Y.cover[m].in;
	     def S=pi.blow.cover[k].in;
		 
		 setring R;
		 ideal base=Y.cover[m].value;
		 int nx=nvars(R);
		 
		 setring S;
		 ideal I=var(1);
		 for(int i=2; i<=nx; i=i+1)
		 {
		    I=I,ideal(var(i));
		 }
		 map phi=R,I;
		 ideal J=phi(base);
		 J=J+pi.blow.cover[k].value;
		 
		 ideal E=pi.exDiv.cover[k].value;
		 
		 J=sat(J,E)[1];
		 chart U=J;
		 result.cover=result.cover+list(U);
		 
		 kill S,i,I,E,nx,U,J,phi,m;
		 setring R;
		 kill base;
		 kill R;
	  }
	  
	  for(int i=1; i<=n; i=i+1)
	  {
		 for(int j=1; j<=n; j=j+1)
		 {
			result.maps[i][j].preim=result.cover[i];
			result.maps[i][j].im=result.cover[j];
		 }
		 kill j;
	  }
	  
	  setring B;
	  return(result);
   }
}
example
{
   "EXAMPLE:"; echo=2;
   ring R=0,(x,y),dp;
   scheme X=makeAffineScheme(ideal(0));
   scheme Y=makeAffineScheme(ideal(x2-y3-y2));
   scheme Z=makeAffineScheme(ideal(x,y));
   list L=blowUp(X,Z);
   scheme blowY=strictTransform(Y,L[2]);
   blowY.maps;
}















//////////////////////////////////////////////////////////////////////////////////
//  Smoothness Test
//////////////////////////////////////////////////////////////////////////////////


// Used in CompleteIntersectionCover and HybrSmoothTest
static proc findMaxMinors(ideal I, matrix J)
"USAGE: findMaxMinors(I,J); I ideal, J matrix
ASSUME: J is Jacobi matrix of II
RETURN: A list of lists of the form (h,A,iv) where h is a maximal minor of J and iv contains 
        the colomns used in the formation of h and A is the matrix of cofactors of the matrix 
		forming h
"
{
   list Minors; 
   ideal Inew=std(I);
   poly h;
   int n=ncols(J);
   int r=nrows(J);
   if(r>1)
   {
   matrix M[r][r];
   matrix A[r][r];
   matrix B[r][r];
   intvec iv=1..r;
   int done;
   int k,l,c,i,j;
   k=r;
   c=0;
   while((k>0)&&(Inew!=1))
   {
      M=submat(J,1..r,iv);
	  h=det(M);
	  if(h!=0)
	  {
	     c=c+1;
	     for(i=1; i<=r; i=i+1)
		 {
		 for(j=1; j<=r; j=j+1)
		 {
		    B=permrow(M,i,r);
			B=permcol(B,j,r);
			A[i,j]=det(submat(B,1..r-1,1..r-1))*(-1)^(i+j);
		 }}
		 A=transpose(A);
	     Minors[c]=list(h,A,iv);
	     Inew=std(radical(Inew+h));
	  }
   
      k=r-1;   
      if(iv[r]<n)
	  {
	     iv[r]=iv[r]+1;
	  }else{
	     done=0;
	     while(!done)
		 {
		    if(iv[k]>=(iv[k+1]-1))
			{
			   k=k-1;
               if(k<=0)
               { done=1;}			   
			}else{ done=1;}
		 }
		 if(k>0)
		 {
		    iv[k]=iv[k]+1;
			l=1;
			while(k+l<=r)
			{
			   iv[k+l]=iv[k+l-1]+1;
			   l=l+1;
			}
		 }
	  }
   }
   return(Minors);
   }else{
   matrix A[r][r];
   int i,c;
   intvec iv;
   c=0;
   i=1;
   while((i<=n)&&(Inew!=1))
   {
      iv=i;
	  h=J[1,i];
	  if(h!=0)
	  {
	     c=c+1;
	     A[1,1]=1;
		 Minors[c]=list(h,A,iv);
	     Inew=std(radical(Inew+h));
	  }
	  i=i+1;
   }
   return(Minors);
   }
}


proc CompleteIntersectionCover(list #)
"USAGE: CompleteIntersectionCover(X,W); X,W schemes
ASSUME: X is a subscheme of W, X and W are equidimensional and smooth and the charts of W are
        complete intersections
RETURN: A list L where:
            L[1] is a scheme isomorphic to X where each chart is a complete intersection
			L[2] is the morphism representing the isomorphism X->L[1]
			L[3] is the morphism representing the isomorphism L[1]->X
EXAMPLE: example CompleteIntersectionCover; gives an example"
{
if((size(#)==1)&&(typeof(#[1])=="ideal"))
{
   def R=basering;
   ideal I=#[1];
   scheme resultScheme;
   morphism resultMap,resultInvMap;
   if((std(I)==0)||(std(I)==1))
   {
      resultScheme=makeAffineScheme(std(I));
	  resultMap.preim=resultScheme;
	  resultMap.im=resultScheme;
	  resultMap.chartmaps=resultScheme.maps;
	  resultInvMap.preim=resultScheme;
	  resultInvMap.im=resultScheme;
	  resultInvMap.chartmaps=resultScheme.maps;
	  return(list(resultScheme,resultMap,resultInvMap));
   }
   else
   {
      matrix J=jacob(I);
	  int i,j,n,k,l,ci,cj;
	  scheme X,W;
      list L,K;
      ideal H=std(radical(I));	
      n=0;	  
	  for(i=1; i<=size(I); i=i+1)
	  {
	     for(j=1; j<=nvars(R); j=j+1)
	     {
	        if(H!=1)
			{
			if(reduce(J[i,j],H)!=0)
			{
			n=n+1;
			L[n]=J[i,j];
			K[n]=i;
			H=std(radical(H+J[i,j]));
			}}
	     }
	  }
	  
	  list CoverSchemes,PreCoverCharts,PreCoverMaps,CoverMaps,CoverInvMaps;
	  for(k=1; k<=n; k=k+1)
	  {
	     poly h=L[k];
	     def S=changevar("x()",R);
		 S=extendring(1,"t","dp",0,S);
		 setring S;
		 ideal VarR=var(2);
		 for(j=2; j<=nvars(R); j=j+1)
		 {
		    VarR=VarR,var(j+1);
		 }
		 map phi=R,VarR;
		 i=K[k];
		 poly hnew=phi(h);
		 poly g=t*hnew-1;
		 
		 ideal Inew=phi(I);
		 poly f=Inew[i];
		 Inew[i]=Inew[1];
		 Inew[1]=f;
		 Inew=g,Inew;
		 
		 W=makeAffineScheme(ideal(g,f));
		 X=makeAffineScheme(Inew,W);
		 
		 PreCoverCharts[k]=X.cover[1];
		 list LL=CompleteIntersectionCover(Inew,ideal(g,f));
		 CoverSchemes[k]=LL[1];
		 CoverMaps[k]=LL[2];
		 CoverInvMaps[k]=LL[3];
		 kill LL;
		 
		 kill phi,hnew,Inew,g,VarR;
		 kill S;
		 setring R;
		 kill h;
	  }
	  
	  for(i=1; i<=n; i=i+1)
	  {
	     list Maps;
		 poly h;
		 chart Preim=PreCoverCharts[i];
		 def S=Preim.in;
		 setring S;
		 ideal VarR=var(2);
		 for(j=2; j<=nvars(R); j=j+1)
		 {
		    VarR=VarR,var(j+1);
		 }
		 map psi=R,VarR;
		 setring R;
		 
	     for(j=1; j<=n; j=j+1)
		 {
		    chartmap phi;
			phi.preim=Preim;
			phi.im=PreCoverCharts[j];
			h=L[j];
			setring S;
			poly hnew=psi(h);
			phi.dom=hnew;
			list RatFuncs;
			RatFuncs[1]=makeratFunc(1,hnew);
			for(k=1; k<=nvars(R); k=k+1)
			{
			   RatFuncs[k+1]=makeratFunc(var(k+1));
			}
			phi.ratFuncs[1]=RatFuncs;
			Maps[j]=phi;
			
			kill hnew,RatFuncs;
			setring R;
			kill phi;
		 }
		 PreCoverMaps[i]=Maps;
		 
		 setring S;
		 kill psi;
		 kill Maps,Preim,S;
		 setring R;
		 kill h;
	  }
	  
	  X=makeAffineScheme(I);
	  list Maps;
	  resultMap.preim=X;
	  resultInvMap.im=X;
	  for(i=1; i<=n; i=i+1)
	  {
	     resultScheme.cover=resultScheme.cover+CoverSchemes[i].cover;
		 
		 chartmap phi,psi;
		 phi.preim=X.cover[1]; phi.im=PreCoverCharts[i];
		 psi.im=X.cover[1]; psi.preim=PreCoverCharts[i];
		 list phiRatFuncs;
		 list psiRatFuncs;
		 
		 phiRatFuncs[1]=makeratFunc(1,L[i]);
		 for(j=1; j<=nvars(R); j=j+1)
		 {
		    phiRatFuncs=phiRatFuncs+list(makeratFunc(var(j)));
		 }
		 phi.dom=ideal(L[i]);
		 phi.ratFuncs[1]=phiRatFuncs;
		 
		 def S=PreCoverCharts[i].in;
		 setring S;
         for(j=1; j<=nvars(R); j=j+1)
		 {
		    psiRatFuncs=psiRatFuncs+list(makeratFunc(var(j+1)));
		 }
		 psi.dom=1;
		 psi.ratFuncs[1]=psiRatFuncs;
		 setring R;
		 
		 
		 for(k=1; k<=size(CoverSchemes[i].cover); k=k+1)
		 {
		    Maps=Maps+list(CoverMaps[i].chartmaps[1][k]*phi);
			resultInvMap.chartmaps=resultInvMap.chartmaps+list(list(psi*CoverInvMaps[i].chartmaps[k][1]));
		 }
		 kill phi,psi,phiRatFuncs,psiRatFuncs,S;
	  }
	  resultMap.chartmaps=list(Maps);
	  
	  
	  ci=0;
	  chartmap phi;
	  for(i=1; i<=n; i=i+1)
	  {
      for(k=1; k<=size(CoverSchemes[i].cover); k=k+1)
	  {
		 ci=ci+1;
		 cj=0;
	     Maps=list();
		 for(j=1; j<=n; j=j+1)
		 {
		 for(l=1; l<=size(CoverSchemes[j].cover); l=l+1)
		 {
		    cj=cj+1;
			if(i==j)
			{
			   Maps[cj]=CoverSchemes[i].maps[k][l];
			}else{
			   phi=CoverMaps[j].chartmaps[1][l];
			   phi=phi*PreCoverMaps[i][j];
			   phi=phi*CoverInvMaps[i].chartmaps[k][1];
			   Maps[cj]=phi;
			}
		 }}
		 resultScheme.maps[ci]=Maps;
	  }}
	  resultMap.im=resultScheme;
	  resultInvMap.preim=resultScheme;
	  
	  return(list(resultScheme,resultMap,resultInvMap));
   }
}

if((size(#)==2)&&(typeof(#[1])=="ideal")&&(typeof(#[2])=="ideal"))
{
   def R=basering;
   ideal IX=#[1];
   ideal IW=#[2];
   if(std(IW)==0)
   {   return(CompleteIntersectionCover(IX));}
   int k;
   int r=size(IW);
   int s=size(IX);
   if(r>s)
   {   ERROR("Incompatible Inputs");}
   for(k=1; k<=r; k=k+1)
   {   if(IW[k]!=IX[k]){ERROR("Incompatible Inputs");}}
   scheme resultScheme;
   morphism resultMap,resultInvMap;
   if(dim(std(IX))==dim(std(IW)))
   {
      resultScheme=makeAffineScheme(IW);
	  resultMap.preim=resultScheme;
	  resultMap.im=resultScheme;
	  resultMap.chartmaps=resultScheme.maps;
	  resultInvMap.preim=resultScheme;
	  resultInvMap.im=resultScheme;
	  resultInvMap.chartmaps=resultScheme.maps;
	  return(list(resultScheme,resultMap,resultInvMap));
   }
   else
   {
      matrix JX=jacob(IX);
	  matrix JW=jacob(IW);
	  int i,j,n,m,l,ci,cj;
	  scheme X,W;
	  list L,K;
	  
      list Minors=findMaxMinors(IW,JW);		  
	  m=size(Minors);
	  n=0;
	  for(k=1; k<=m; k=k+1)
	  {
	     matrix v[s][1];
		 for(i=1; i<=s; i=i+1)
		 {
		    v[i,1]=IX[i];
		 }
		 matrix M=dsum(Minors[k][2],diag(Minors[k][1],s-r));
		 ideal I=M*v;
		 matrix J=jacob(I);
		 intvec iv=Minors[k][3];
		 for(i=r+1; i<=s; i=i+1)
		 {
		    for(j=1; j<=r; j=j+1)
			{
			   poly g=-diff(IX[i],var(iv[j]));
			   J=addrow(J,j,g,i);
			   kill g;
			}
		 }
		 
		 ideal H=std(radical(IW));
		 for(i=r+1; i<=s; i=i+1)
	     {
		 l=1;
	     for(j=1; j<=nvars(R); j=j+1)
	     {
	        if(reduce(Minors[k][1],H)!=0)
			{
			if(j!=iv[l])
			{
			if(reduce(J[i,j],H)!=0)
			{
			n=n+1;
			L[n]=J[i,j]*Minors[k][1];
			K[n]=i;
			H=std(radical(H+J[i,j]));
			}}
			else{
			if(l<r){l=l+1;}
			}}
	     }
	     }
		 
		 kill v,M,I,J,iv,H;
	  }
	  
	  list CoverSchemes,PreCoverCharts,PreCoverMaps,CoverMaps,CoverInvMaps;
	  for(k=1; k<=n; k=k+1)
	  {
	     poly h=L[k];
	     def S=changevar("x()",R);
		 S=extendring(1,"t","dp",0,S);
		 setring S;
		 ideal VarR=var(2);
		 for(j=2; j<=nvars(R); j=j+1)
		 {
		    VarR=VarR,var(j+1);
		 }
		 map phi=R,VarR;
		 i=K[k];
		 poly hnew=phi(h);
		 poly g=t*hnew-1;
		 poly f;
		 
		 ideal IXnew=phi(IX);
		 ideal IWnew=phi(IW);
		 if(std(IWnew)!=0)
		 {
		 f=IXnew[i];
		 IXnew[i]=IXnew[r+1];
		 IXnew[r+1]=f;
		 IXnew=g,IXnew;
		 IWnew=g,IWnew,f;
		 }else{
		 f=IXnew[i];
		 IXnew[i]=IXnew[1];
		 IXnew[1]=f;
		 IXnew=g,IXnew;
		 IWnew=g,f;
		 }
		 
		 W=makeAffineScheme(IWnew);
		 X=makeAffineScheme(IXnew,W);
		 
		 PreCoverCharts[k]=X.cover[1];
		 list LL=CompleteIntersectionCover(IXnew,IWnew);
		 CoverSchemes[k]=LL[1];
		 CoverMaps[k]=LL[2];
		 CoverInvMaps[k]=LL[3];
		 kill LL;
		 
		 kill phi,hnew,VarR,f,g,IXnew,IWnew;
		 setring R;
		 kill S;
		 kill h;
	  }
	  
	  for(i=1; i<=n; i=i+1)
	  {
	     list Maps;
		 poly h;
		 chart Preim=PreCoverCharts[i];
		 def S=Preim.in;
		 setring S;
		 ideal VarR=var(2);
		 for(j=2; j<=nvars(R); j=j+1)
		 {
		    VarR=VarR,var(j+1);
		 }
		 map psi=R,VarR;
		 setring R;
		 
	     for(j=1; j<=n; j=j+1)
		 {
		    chartmap phi;
			phi.preim=Preim;
			phi.im=PreCoverCharts[j];
			h=L[j];
			setring S;
			poly hnew=psi(h);
			phi.dom=hnew;
			list RatFuncs;
			RatFuncs[1]=makeratFunc(1,hnew);
			for(k=1; k<=nvars(R); k=k+1)
			{
			   RatFuncs[k+1]=makeratFunc(var(k+1));
			}
			phi.ratFuncs[1]=RatFuncs;
			Maps[j]=phi;
			
			kill hnew,RatFuncs;
			setring R;
			kill phi;
		 }
		 PreCoverMaps[i]=Maps;
		 setring S;
		 kill VarR,psi;
		 setring R;
		 kill Maps,Preim,S,h;
	  }
	  
	  X=makeAffineScheme(IX);
	  list Maps;
	  resultMap.preim=X;
	  resultInvMap.im=X;
	  for(i=1; i<=n; i=i+1)
	  {
	     resultScheme.cover=resultScheme.cover+CoverSchemes[i].cover;
		 
		 chartmap phi,psi;
		 phi.preim=X.cover[1]; phi.im=PreCoverCharts[i];
		 psi.im=X.cover[1]; psi.preim=PreCoverCharts[i];
		 list phiRatFuncs;
		 list psiRatFuncs;
		 
		 phiRatFuncs[1]=makeratFunc(1,L[i]);
		 for(j=1; j<=nvars(R); j=j+1)
		 {
		    phiRatFuncs=phiRatFuncs+list(makeratFunc(var(j)));
		 }
		 phi.dom=ideal(L[i]);
		 phi.ratFuncs[1]=phiRatFuncs;
		 
		 def S=PreCoverCharts[i].in;
		 setring S;
         for(j=1; j<=nvars(R); j=j+1)
		 {
		    psiRatFuncs=psiRatFuncs+list(makeratFunc(var(j+1)));
		 }
		 psi.dom=1;
		 psi.ratFuncs[1]=psiRatFuncs;
		 setring R;
		 
		 for(k=1; k<=size(CoverSchemes[i].cover); k=k+1)
		 {
		    Maps=Maps+list(CoverMaps[i].chartmaps[1][k]*phi);
			resultInvMap.chartmaps=resultInvMap.chartmaps+list(list(psi*CoverInvMaps[i].chartmaps[k][1]));
		 }
		 kill phi,psi,phiRatFuncs,psiRatFuncs,S;
	  }
	  resultMap.chartmaps=list(Maps);
	  
	  ci=0;
	  chartmap phi;
	  for(i=1; i<=n; i=i+1)
	  {
      for(k=1; k<=size(CoverSchemes[i].cover); k=k+1)
	  {
		 ci=ci+1;
		 cj=0;
	     Maps=list();
		 for(j=1; j<=n; j=j+1)
		 {
		 for(l=1; l<=size(CoverSchemes[j].cover); l=l+1)
		 {
		    cj=cj+1;
			if(i==j)
			{
			   Maps[cj]=CoverSchemes[i].maps[k][l];
			}else{
			   phi=CoverMaps[j].chartmaps[1][l];
			   phi=phi*PreCoverMaps[i][j];
			   phi=phi*CoverInvMaps[i].chartmaps[k][1];
			   Maps[cj]=phi;
			}
		 }}
		 resultScheme.maps[ci]=Maps;
	  }}
	  resultMap.im=resultScheme;
	  resultInvMap.preim=resultScheme;
	  
	  return(list(resultScheme,resultMap,resultInvMap));
   }   
}

if((size(#)==2)&&(typeof(#[1])=="scheme")&&(typeof(#[2])=="scheme"))
{
   def R=basering;
   scheme X=#[1];
   scheme W=#[2];
   scheme resultScheme;
   int i,j,k,l;
   int n=size(X.cover);
   morphism resultMap,resultInvMap;
   
   list CoverSchemes,CoverMaps,CoverInvMaps;
   for(i=1; i<=n; i=i+1)
   {
      def S=X.cover[i].in;
	  setring S;
	  ideal IX=X.cover[i].value;
	  ideal IW=W.cover[i].value;
	  list LL=CompleteIntersectionCover(IX,IW);
	  CoverSchemes[i]=LL[1];
	  CoverMaps[i]=LL[2];
	  CoverInvMaps[i]=LL[3];
	  
	  kill IX,IW;
	  setring R;
	  kill S,LL;
   }

   
   list Maps;
   resultMap.preim=X;
   resultInvMap.im=X;
   for(i=1; i<=n; i=i+1)
   {
	  resultScheme.cover=resultScheme.cover+CoverSchemes[i].cover;
   }
   
   for(i=1; i<=n; i=i+1)
   {
      Maps=list();
	  for(j=1; j<=n; j=j+1)
	  {
	  for(k=1; k<=size(CoverSchemes[j].cover); k=k+1)
	  {
		 if(i!=j)
		 {
		    chartmap phi;
			phi.preim=X.cover[i];
			phi.im=CoverSchemes[j].cover[k];
			
			def S=X.cover[i].in;
			setring S;
			phi.dom=0;
			
			def SS=CoverSchemes[j].cover[k].in;
			phi.ratFuncs[1]=list();
			for(l=1; l<=nvars(SS); l=l+1)
			{
			   phi.ratFuncs[1]=phi.ratFuncs[1]+list(makeratFunc(0));
			}
			Maps=Maps+list(phi);
			kill phi,S,SS;
			setring R;
		 }else{
		    Maps=Maps+list(CoverMaps[i].chartmaps[1][k]);
		 }
	  }}
	  resultMap.chartmaps[i]=Maps;
   }
   
   for(j=1; j<=n; j=j+1)
   {
   for(k=1; k<=size(CoverSchemes[j].cover); k=k+1)
   {
      Maps=list();
      for(i=1; i<=n; i=i+1)
	  {
	     if(i!=j)
		 {
		    chartmap phi;
			phi.im=X.cover[i];
			phi.preim=CoverSchemes[j].cover[k];
			
			def S=CoverSchemes[j].cover[k].in;
			setring S;
			phi.dom=0;
			
			def SS=X.cover[i].in;
			phi.ratFuncs[1]=list();
			for(l=1; l<=nvars(SS); l=l+1)
			{
			   phi.ratFuncs[1]=phi.ratFuncs[1]+list(makeratFunc(0));
			}
			Maps=Maps+list(phi);
			kill phi,S,SS;
			setring R;
		 }else{
		    Maps=Maps+list(CoverInvMaps[i].chartmaps[k][1]);
		 }
	  }
	  resultInvMap.chartmaps=resultInvMap.chartmaps+list(Maps);
   }}
   
   for(i=1; i<=n; i=i+1)
   {
   for(k=1; k<=size(CoverSchemes[i].cover); k=k+1)
   {
      Maps=list();
      for(j=1; j<=n; j=j+1)
	  {
	  for(l=1; l<=size(CoverSchemes[j].cover); l=l+1)
	  {
	     chartmap phi=CoverMaps[j].chartmaps[1][l];
		 phi=phi*X.maps[i][j];
		 phi=phi*CoverInvMaps[i].chartmaps[k][1];
		 Maps=Maps+list(phi);
		 kill phi;
	  }}
	  resultScheme.maps=resultScheme.maps+list(Maps);
   }}
   resultMap.im=resultScheme;
   resultInvMap.preim=resultScheme;

   return(list(resultScheme,resultMap,resultInvMap));
}
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(0);
scheme Z=makeProjScheme(ideal(x-z,y-z)*ideal(x+z,y-z),X);

list LL=CompleteIntersectionCover(Z,X);
LL[1];
}



proc HybrSmoothTest(list #)
"USAGE: HybrSmoothTest(X[,W]); X,W schemes
RETURN: 1 if X is smooth, 0 otherwise
EXAMPLE: example HybrSmoothTest; shows an example"
{
if((size(#)==2)&&(typeof(#[1])=="chart")&&(typeof(#[2])=="chart"))
{
   int result=1;
   def T=basering;
   if(#[1].in!=#[2].in)
   {   ERROR("Incompatible Inputs");}
   def R=#[1].in;
   setring R;   
   ideal IX=#[1].value;
   ideal IW=#[2].value;
   int k;
   int r=size(IW);
   int s=size(IX);
   if(r>s)
   {   ERROR("Incompatible Inputs");}
   for(k=1; k<=r; k=k+1)
   {   if(IW[k]!=IX[k]){  ERROR("Incompatible Inputs");}}
   if(dim(std(IX))==dim(std(IW)))
   {
      if((std(reduce(std(IX),std(IW)))==0)&&(std(reduce(std(IW),std(IX)))==0))
	  {   result=1;}
	  else
	  {   result=0;}
	  setring T;
	  return(result);
   }
   else
   {
      matrix JX=jacob(IX);
	  matrix JW=jacob(IW);
	  int i,j,n,m,l,ci,cj;
	  list L,K;	 
      if(std(IW)!=0)
      {	  
      list Minors=findMaxMinors(IW,JW);		  
	  m=size(Minors);
	  n=0;
	  for(k=1; k<=m; k=k+1)
	  {
	     matrix v[s][1];
		 for(i=1; i<=s; i=i+1)
		 {
		    v[i,1]=IX[i];
		 }
		 matrix M=dsum(Minors[k][2],diag(Minors[k][1],s-r));
		 ideal I=M*v;
		 matrix J=jacob(I);
		 intvec iv=Minors[k][3];
		 for(i=r+1; i<=s; i=i+1)
		 {
		    for(j=1; j<=r; j=j+1)
			{
			   poly g=-diff(IX[i],var(iv[j]));
			   J=addrow(J,j,g,i);
			   kill g;
			}
		 }
		 
		 ideal H=std(radical(IW));
		 for(i=r+1; i<=s; i=i+1)
	     {
		 l=1;
	     for(j=1; j<=nvars(R); j=j+1)
	     {
	        if(reduce(Minors[k][1],H)!=0)
			{
			if(j!=iv[l])
			{
			if(reduce(J[i,j],H)!=0)
			{
			n=n+1;
			L[n]=J[i,j]*Minors[k][1];
			K[n]=i;
			H=std(radical(H+J[i,j]));
			}}
			else{
			if(l<r){l=l+1;}
			}}
	     }
	     }
		 
		 if(std(H)!=1)
		 {   result=0;
		     return(result);
		 }
		 
		 kill v,M,I,J,iv,H;
	  }
	  }else{
	  ideal H=std(radical(IX));	
	  matrix J=jacob(IX);
      n=0;	  
	  for(i=1; i<=size(IX); i=i+1)
	  {
	     for(j=1; j<=nvars(R); j=j+1)
	     {
	        if(H!=1)
			{
			if(reduce(J[i,j],H)!=0)
			{
			n=n+1;
			L[n]=J[i,j];
			K[n]=i;
			H=std(radical(H+J[i,j]));
			}}
	     }
	  }
	  if(H!=1)
	  {   result=0;
	      return(result);
	  }
	  }
   
   
      for(k=1; k<=n; k=k+1)
      {
	     poly h=L[k];
	     def S=changevar("x()",R);
		 S=extendring(1,"t","dp",0,S);
		 setring S;
		 setring S;
		 ideal VarR=var(2);
		 for(j=2; j<=nvars(R); j=j+1)
		 {
		    VarR=VarR,var(j+1);
		 }
		 map phi=R,VarR;
		 i=K[k];
		 poly hnew=phi(h);
		 poly g=t*hnew-1;
		 poly f;
		 
		 ideal IXnew=phi(IX);
		 ideal IWnew=phi(IW);
		 if(std(IWnew)!=0)
		 {
		 f=IXnew[i];
		 IXnew[i]=IXnew[r+1];
		 IXnew[r+1]=f;
		 IXnew=g,IXnew;
		 IWnew=g,IWnew,f;
		 }else{
		 f=IXnew[i];
		 IXnew[i]=IXnew[1];
		 IXnew[1]=f;
		 IXnew=g,IXnew;
		 IWnew=g,f;
		 }
		 
		 chart X=IXnew;
		 chart W=IWnew;
		 if(!HybrSmoothTest(X,W))
		 {   result=0;
		     return(result);
		 }
		 
		 
		 kill phi,hnew,VarR,f,g,IXnew,IWnew,X,W;
		 kill S;
		 setring R;
		 kill h;
	   }
	   
	   setring T;
       return(result);
	}
}

if((size(#)==1)&&(typeof(#[1])=="scheme"))
{
   def R=basering;
   int result=1;
   scheme X=#[1];
   for(int n=1; n<=size(X.cover); n=n+1)
   {
      def S=X.cover[n].in;
	  setring S;
	  chart W=0;
	  setring R;
	  kill S;
      if(!HybrSmoothTest(X.cover[n],W))
	  {   result=0;}
	  kill W;
   }
   return(result);
}

if((size(#)==2)&&(typeof(#[1])=="scheme")&&(typeof(#[2])=="scheme"))
{
   int result=1;
   scheme X=#[1];
   scheme W=#[2];
   if(size(W.cover)!=size(X.cover))
   {   ERROR("Incompatible Inputs");}
   for(int n=1; n<=size(X.cover); n=n+1)
   {
      if(!HybrSmoothTest(X.cover[n],W.cover[n]))
	  {   result=0;}
   }
   return(result);
}
}
example
{"EXAMPLE:"; "echo=1";

ring R=0,(x,y),dp;
"Example of a smooth scheme";
scheme X=makeAffineScheme(ideal(y-x2));
HybrSmoothTest(X);

"Example of a scheme that isn't smooth";
scheme Y=makeAffineScheme(ideal(y2-x3));
HybrSmoothTest(Y);

"Blowing up resolves singularities";
scheme C=makeAffineScheme(ideal(x,y),Y);
scheme Z=blowUp(Y,C)[1];
HybrSmoothTest(Z);
}



proc isSmooth(scheme X)
"USAGE: isSmooth(X); scheme X
RETURN: 1 if X is smooth, 0 otherwise
EXAMPLE: example isSmooth; gives an example"
{
   def R=basering;   
   int i,j,k;
   
   if(!isReduced(X))
   {   return(0);}
   
   list Dec=IrredDec(X);
   for(i=1; i<=size(X.cover); i=i+1)
   {
      def S=X.cover[i].in;
      setring S;
      for(j=1; j<=size(Dec)-1; j=j+1)
      {
      for(k=j+1; k<=size(Dec); k=k+1)
      {
	     if(std(Dec[j][1].cover[i].value+Dec[k][1].cover[i].value)!=1)
		 {
		    return(0);
		 }
      }}
	  kill S;
   }
   
   setring R;
   for(j=1; j<=size(Dec); j=j+1)
   {
      if(!HybrSmoothTest(Dec[j][1]))
	  {
	     return(0);
	  }
   }
   
   setring R;
   return(1);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme X=makeProjScheme(x2y3z5);
isSmooth(X);

X=makeProjScheme(ideal(xyz-x3));
isSmooth(X);

X=makeAffineScheme(ideal(x2y-x));
isSmooth(X);

X=makeProjScheme(y2x-x3-x2z);
isSmooth(X);

scheme Z=makeProjScheme(ideal(x,y),X);
list L=blowUp(X,Z);
isSmooth(L[1]);
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Iterative Scheme Stuff
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

proc maps(int n, int m, iterativeScheme X)
"USAGE: maps(i,j,X); int i,j ,iterativeScheme X
RETURN: the gluing map from the i-th to the j-th chart
EXAMPLE: example maps; gives an example"
{
   	def R=basering;
   
   	chartmap result,phi,psi;
   	intvec v=X.cover[n].label;
   	intvec w=X.cover[m].label;
	int sv=size(v);
	int sw=size(w);

	phi.preim=X.cover[n].entry;
	phi.im=X.cover[n].entry;
	def S=X.cover[n].entry.in;
	setring S;
	phi.dom=ideal(1);
	phi.ratFuncs[1]=list();
	for(int i=1; i<=nvars(S); i=i+1)
	{
		ratFunc F=var(i);
		phi.ratFuncs[1][i]=F;
		kill F;
	}
	kill S,i;
	setring R;

	psi.preim=X.cover[m].entry;
	psi.im=X.cover[m].entry;
	def S=X.cover[m].entry.in;
	setring S;
	psi.dom=ideal(1);
	psi.ratFuncs[1]=list();
	for(int i=1; i<=nvars(S); i=i+1)
	{
		ratFunc F=var(i);
		psi.ratFuncs[1][i]=F;
		kill F;
	}
	kill S,i;
	setring R;

	int k=0;
	int done=0;
	while((k<sv)&&(k<sw)&&(!done))
	{
		if(v[k+1]!=w[k+1])
		{
			done=1;
		}else{
			k=k+1;
		}
	}
	kill done;

	int l=sv-1;
	if(l>=1)
	{
		iterativeChart U=X.cover[n];
		while((l>=k)&&(l>=1))
		{
			phi=U.parentmap*phi;
			l=l-1;
			if(l>=1)
			{
				def V=U.parent;
				U=V;
				kill V;
			}
		}
		kill U;
	}
	kill l;

	int l=sw-1;
	if(l>=1)
	{
		iterativeChart U=X.cover[m];
		while((l>=k)&&(l>=1))
		{
			psi=psi*U.parentInverseMap;
			l=l-1;
			if(l>=1)
			{
				def V=U.parent;
				U=V;
				kill V;
			}
		}
		kill U;
	}
	kill l;

	if(k!=0)
	{
		result=psi*phi;
	}else{
		int i=v[1];
		int j=w[1];
		result=psi*X.maps[i][j]*phi;
		kill i,j;
	}

	int i;
	def S=result.preim.in;
	setring S;
	for(k=1; k<=ncols(result.dom); k=k+1)
	{
		poly p=1;
		for(i=1; i<=nvars(result.im.in); i=i+1)
		{
			p=lcm(p,result.ratFuncs[k][i].den);
		}
		result.dom[k]=p;
		kill p;
	}
	kill i,k,S;

	return(result);
   	setring R;
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme W=makeProjScheme(0);
scheme X=makeProjScheme(ideal(x-z,y-z)*ideal(x+z,y-z),W);

iterativeScheme Z=itCompleteIntersectionCover(X,W);
maps(6,8,Z);
}





proc itCompleteIntersectionCover(def X, def W)
"USAGE: itCompleteIntersectionCover(X,W); X,W schemes/iterativeSchemes
ASSUME: X is a subscheme of W, X and W are equidimensional and smooth and the charts of W are
        complete intersections
RETURN: iterativeScheme Z that is isomorphic to X but whose charts are complete intersections
EXAMPLE: example itCompleteIntersectionCover; gives an example"
{
   def R=basering;
   
   iterativeScheme XX;
   if(typeof(X)=="scheme")
   {
	  XX.maps=X.maps;
	  int n=size(X.cover);
	  iterativeChart C;
	  for(int i=1; i<=n; i=i+1)
	  {
	     C.entry=X.cover[i];
		 C.label=i;
		 XX.cover=XX.cover+list(C);
	  }
	  kill n,C,i;	  
   }else{  XX=X;}
   
   iterativeScheme WW;
   if(typeof(W)=="scheme")
   {
	  WW.maps=W.maps;
	  int n=size(W.cover);
	  iterativeChart C;
	  for(int i=1; i<=n; i=i+1)
	  {
	     C.entry=W.cover[i];
		 C.label=i;
		 WW.cover=WW.cover+list(C);
	  }
	  kill n,C,i;	  
   }else{  WW=W;}
   
   int n,m;
   list Cover;
   for(n=1; n<=size(WW.cover); n=n+1)
   {
	  def S=WW.cover[n].entry.in;
	  setring S;
	  Poly p=1;
	  Cover=Cover+list(list(XX.cover[n].entry,WW.cover[n].entry,p,n));
	  kill p;
	  kill S;
   }

   n=1;
   while(n<=size(Cover))
   {
	  m=Cover[n][4];
      def S=Cover[n][1].in;
	  setring S;
	  ideal IX=Cover[n][1].value;
	  ideal IW=Cover[n][2].value;
	  poly p=Cover[n][3].value;
	  int r=size(IW);
	  int s=size(IX);
	  if(dim(sat(IX,p)[1])>=dim(sat(IW,p)[1]))
	  {
		 Cover[n][1]=Cover[n][2];
	     n=n+1;
	  }else{
	     if(r==0)
		 {
		    matrix J=jacob(IX);
	        int i,j,k,l;
            list L,K;
            ideal H=std(radical(IX));		  
	        for(i=1; i<=size(IX); i=i+1)
	        {
	           for(j=1; j<=nvars(S); j=j+1)
	           {
	              if(reduce(p,H)!=0)
			      {
			      if(reduce(J[i,j],H)!=0)
			      {
			      L=L+list(J[i,j]);
			      K=K+list(i);
			      H=std(radical(H+J[i,j]));
			      }}
	           }
	        }
	  
	        for(k=1; k<=size(L); k=k+1)
	        {
	           poly h=L[k];
		       i=K[k];

               ideal Inew=IX;
		       poly f=Inew[i];
		       Inew[i]=Inew[1];
		       Inew[1]=f;

			   Cover=insert(Cover,list(makeChart(Inew),makeChart(ideal(f)),makePoly(p*h),m),n); 
			   
		       kill h,Inew,f;
			}
			
			kill i,j,l,k,L,K,J,H;
		 }else{
		    matrix JX=jacob(IX);
	        matrix JW=jacob(IW);
	        int i,j,l,k,ci,cj;
	        list L,K;
	  
            list Minors=findMaxMinors(IW,JW);
	        for(k=1; k<=size(Minors); k=k+1)
	        {
	           matrix v[s][1];
		       for(i=1; i<=s; i=i+1)
		       {
		          v[i,1]=IX[i];
		       }
		       matrix M=dsum(Minors[k][2],diag(Minors[k][1],s-r));
		       ideal I=M*v;
		       matrix J=jacob(I);
		       intvec iv=Minors[k][3];
		       for(i=r+1; i<=s; i=i+1)
		       {
		          for(j=1; j<=r; j=j+1)
			      {
			         poly g=-diff(IX[i],var(iv[j]));
			         J=addrow(J,j,g,i);
			         kill g;
			      }
		       }
		 
		       ideal H=std(radical(IW));
		       for(i=r+1; i<=s; i=i+1)
	           {
		       l=1;
	           for(j=1; j<=nvars(S); j=j+1)
	           {
	              if(reduce(p*Minors[k][1],H)!=0)
			      {
			      if(j!=iv[l])
			      {
			      if(reduce(J[i,j],H)!=0)
			      {
			      L=L+list(J[i,j]*Minors[k][1]);
			      K=K+list(i);
			      H=std(radical(H+J[i,j]));
			      }}
			      else{
			      if(l<r){l=l+1;}
			      }}
	           }
	           }
		       kill v,M,I,J,iv,H;
	        }
	  
	        for(k=1; k<=size(L); k=k+1)
	        {
      	       poly h=L[k];
		       i=K[k];
		 
		       ideal IXnew=IX;
		       ideal IWnew=IW;
		       poly f=IXnew[i];
		       IXnew[i]=IXnew[r+1];
		       IXnew[r+1]=f;
		       IWnew=IWnew,f;
			   
			   Cover=insert(Cover,list(makeChart(IXnew),makeChart(IWnew),makePoly(p*h),m),n);

		       kill h,IXnew,IWnew,f;
			}
			kill i,j,l,k,ci,cj,L,K;
			kill Minors,JX,JW;
		 }
		 
		 Cover=delete(Cover,n);
	  }
	  
	  setring S;
	  kill IW,IX,r,s,p;
	  kill S;
   }

   iterativeScheme result;
   result.maps=XX.maps;
   for(n=1; n<=size(Cover); n=n+1)
   {
	  int i=n;
	  intvec v;
	  iterativeChart C;
	  m=Cover[n][4];
	  v=XX.cover[m].label;
	  C.label=v,i;
	  C.parent=XX.cover[m];

	  def S=XX.cover[m].entry.in;
	  setring S;
	  ideal I=Cover[n][1].value;
	  poly f=Cover[n][3].value;

	  def T=changevar("x()",S);
	  T=extendring(1,"t","dp",1,T);
	  setring T;
	  ideal I=fetch(S,I);
	  poly f=fetch(S,f);
	  I=I,t*f-1;
	  C.entry=makeChart(I);

      chartmap phi,psi;
	  phi.preim=XX.cover[m].entry;
	  psi.im=XX.cover[m].entry;
	  phi.im=C.entry;
	  psi.preim=C.entry;

      psi.dom=ideal(1);
	  psi.ratFuncs[1]=list();
	  for(i=1; i<=nvars(T)-1; i=i+1)
	  {
		  psi.ratFuncs[1][i]=makeratFunc(var(i));
	  }
	  C.parentmap=psi;
      kill I,f;
	  kill T;

	  setring S;
	  phi.dom=ideal(f);
	  phi.ratFuncs[1]=list();
	  for(i=1; i<=nvars(S); i=i+1)
	  {
		  phi.ratFuncs[1][i]=makeratFunc(var(i));
	  }
	  phi.ratFuncs[1][nvars(S)+1]=makeratFunc(1,f);
	  C.parentInverseMap=phi;
	  kill I,f;
	  kill S;

      result.cover[n]=C;
	  kill i,C,v,phi,psi;
   }
   
   setring R;
   return(result);
}
example
{"EXAMPLE:";
ring R=0,(x,y,z),dp;
scheme W=makeProjScheme(0);
scheme X=makeProjScheme(ideal(x-z,y-z)*ideal(x+z,y-z),W);

iterativeScheme Z=itCompleteIntersectionCover(X,W);
}


proc schemeToIterativeScheme(scheme X)
{
	iterativeScheme result;
	result.maps=X.maps;
	int i;
	for(i=1; i<=size(X.cover); i=i+1)
	{
		iterativeChart U;
		U.entry=X.cover[i];
		U.label=i;
		result.cover[i]=U;
		kill U;
	}
	kill i;
	return(result);
}


proc iterativeSchemetoScheme(iterativeScheme X)
{
	scheme result;
	int i,j;
	for(i=1; i<=size(X.cover); i=i+1)
	{
		result.cover[i]=X.cover[i].entry;
		result.maps[i]=list();
		for(j=1; j<=size(X.cover); j=j+1)
		{
			result.maps[i][j]=maps(i,j,X);
		}
	}
	kill i,j;
	return(result);
}


static proc printItChart(iterativeChart C)
{
   C.entry;
}


static proc printItScheme(iterativeScheme X)
{
   //to be done
}



//////////////////////////////////////////////////////////////////////////////////////////////////////
//   Cone decomposition
//////////////////////////////////////////////////////////////////////////////////////////////////////


proc subcones(intmat M)
{
	int d=Gfan::dimension(coneViaPoints(M));
	intmat S[d][ncols(M)];
	list L;

	L=subsetUtil(M,d,S,1,0,L);
	kill S;
	return(L);
}


static proc subsetUtil(intmat M, int d, intmat S, int i, int j, list L)
{
	list result=L;

	if(j>=d)
	{
		cone c=Gfan::coneViaPoints(S);
		result=insert(result,c);
		kill c;
		return(result);
	}

	if(i>nrows(M))
	{
		return(result);
	}

	S[j+1,1..ncols(M)]=M[i,1..ncols(M)];

	if(Gfan::dimension(Gfan::coneViaPoints(S))==j+1)
	{
		result=subsetUtil(M,d,S,i+1,j+1,result);
	}

	result=subsetUtil(M,d,S,i+1,j,result);

	return(result);
}


proc fanDecomposition(intmat M, list #)
{
	
	cone C=Gfan::coneViaPoints(M);
	int i,j,k;
	int d=Gfan::dimension(C);
	list L=subcones(M);
	fan F=Gfan::emptyFan(Gfan::ambientDimension(C));
	if(size(#)==1)
	{
		bigintmat P=bigintmat(#[1]);
		for(i=1; i<=size(L); i=i+1)
		{
			bigintmat I=Gfan::inequalities(L[i]);
			bigintmat S=I*transpose(P);
			bigintmat T[1][nrows(S)];
			if(containsInSupport(L[i],P))
			{
			cone D;
			for(j=1; j<=nrows(S); j=j+1)
			{
				if(S[j,1]>0)
				{
					T=I[j,1..nrows(S)];
					D=Gfan::coneViaInequalities(T);
					C=Gfan::convexIntersection(C,D);
				}
			}
			kill D;
			}
			kill I,S,T;
		}

		i=1;
		while(i<=size(L))
		{
			int alreadyIn=0;
			j=1;
			cone D=Gfan::convexIntersection(L[i],C);
			while((j<i) && (!alreadyIn))
			{
				if(D==L[j])
				{
					alreadyIn=1;
				}
				j=j+1;
			}

			if((alreadyIn) || (Gfan::dimension(D)<d))
			{
				L=delete(L,i);
			}else{
				L[i]=D;
				i=i+1;
			}
			kill alreadyIn,D;
		}

		kill P;
	}
	list LF=list(C);
	for(i=1; i<=size(L); i=i+1)
	{
		intmat N=intmat(Gfan::inequalities(L[i]));
		for(j=1; j<=nrows(N); j=j+1)
		{
			list G;
			intmat P[1][ncols(N)]=N[j,1..ncols(N)];
			cone D=Gfan::coneViaInequalities(P);
			for(k=1; k<=size(LF); k=k+1)
			{
			    //"i="+string(i)+"/"+string(size(L))+", j="+string(j)+"/"+string(nrows(N))+", k="+string(k)+"/"+string(size(LF));
				cone E;
				E=Gfan::convexIntersection(LF[k],D);
				if(Gfan::dimension(E)==d)
				{
					G=insert(G,E);
				}
				E=Gfan::convexIntersection(LF[k],Gfan::negatedCone(D));
				if(Gfan::dimension(E)==d)
				{
					G=insert(G,E);
				}
				kill E;
			}
			LF=G;
			kill G,D,P;
		}
		kill N;
	}

	for(i=1; i<=size(LF); i=i+1)
	{
		insertCone(F,LF[i]);
	}

	kill C,d,L,i,j,k;
	return(F);
	kill F;
}