//
version="version idealclass.lib 1.0.0.1 Apr_2021 ";
category="Algebraic geometry"; 
info="
LIBRARY: idealclass.lib  Ring independent ideal data type

AUTHORS:  Benjamin Mirgain
          Janko Boehm, e-mail:boehm@mathematik.uni-kl.de

OVERVIEW:
This library implements a ring independent ideal type used in scheme.lib. You can use
+, * and ^ for addition, multiplication and exponentiation. The key in contains the 
base ring of the ideal, the key value contains the ideal. You can call the constructor 
by asigning an ideal of the type ideal to an ideal of the type Ideal via =.

KEYWORDS:
ideals

PROCEDURES:
makeIdeal(I);  constructor for the Ideal type
";

static proc mod_init()
{
  newstruct("Ideal","ring in, ideal value");
  system("install","Ideal","print",printIdeal,1);
  system("install","Ideal","string",stringIdeal,4);
  system("install","Ideal","+",addIdeal,2);
  system("install","Ideal","*",multIdeal,2);
  system("install","Ideal","^",expIdeal,2);
  system("install","Ideal","=",makeIdeal,1);
}


proc makeIdeal(ideal i)
"USAGE: makeIdeal(I); I ideal
RETURN: make a ring independent Ideal from Ideal
EXAMPLE: example makePoly, shows an example"
{
Ideal I;
I.in=basering;
I.value=i;
return(I);
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
Ideal I=ideal(2x3+x2y-1,y2+3);
Ideal J=ideal(x+y,y2+1);
I+J;
I*J;
J^2;
string(I);
}


proc printIdeal(Ideal I)
"USAGE: printIdeal(I); I Ideal
RETURN: print Ideal
EXAMPLE: example printIdeal, shows an example"
{
def SS=I.r_value;
setring SS;
I.value;
kill SS;
}
example
{"EXAMPLE:";
ring R=0,(x,y),dp;
Ideal I=ideal(4x3+2x2y-1,5y2-xy+3);
I;
}



static proc stringIdeal(Ideal I)
{
def S=I.r_value;
setring S;
string st=string(I.value);
kill S;
return(st);
}



static proc addIdeal(Ideal I,Ideal J)
{
def S=I.r_value;
setring S;
Ideal IplusJ=I.value+J.value;
kill S;
return(IplusJ);
}



static proc multIdeal(Ideal I,Ideal J)
{
def S=I.r_value;
setring S;
Ideal ItimesJ=(I.value)*(J.value);
kill S;
return(ItimesJ);
}




static proc expIdeal(Ideal I,int n)
{
def S=I.r_value;
setring S;
Ideal Iexpn=(I.value)^n;
kill S;
return(Iexpn);}

